Parameters f_shabl, f_othet, rep_config
rep_time=Seconds()
ret_error=RTF_REPORT(m.f_shabl,m.f_othet,m.rep_config)
rep_time=Seconds()-m.rep_time
? "Время выполнения: "+Str(Int(rep_time/60),3)+":"+Chrtran(Str(Mod(rep_time,60),2)," ","0")+" сек."
If !Empty(m.ret_error)
  =Messagebox(m.ret_error,16,"Ошибка")
Endif
Return m.ret_error
*############################################################################################
*############################################################################################
*############################################################################################
Function RTF_REPORT  && формирование отчета на основе описанного RTF шаблона
Parameters f_shabl, f_othet, rep_config
* f_shabl - файл шаблона
* f_othet - файл результата
* rep_config - Конфигурация запуска - может содержать любой набор из нижеперечисленных вариантов:
*  [SHOW]  - показать отчет
*  [ADDF]  - автоматически создавать файл результата с возрастающим номером, в случае, если не удается переписать файл
*  [MERGE] - Объединить текущий результат с существующим файлом WORD. Исключает параметр [ADDF]
*  [HIDE]  - не показывать сообщения пользователю о процессе генерации
*  [PRINT] или [PRINT=имя_принтера] - для печати отчета без просмотра. После знака равенства можно задать целевой принтер.
*  [COPIES=*] для печати * копий отчета.
*  [PAGES=1,2,5-8] для печати заданных страниц | [PAGES=BOOK] для формирования книжки | [PAGES=SIDE] - для печати четных и нечетных страниц
*   [FORMAT] - Обновление оглавления, если оно есть (только если установлен MS Office)
*  [ENCODE=N] - Позволяет записывать все данные отчета в перекодированном виде. Варианты N см. в параметрах ф-и STRCONV()
*   [EXCEL] - Не зависимо от настроек POINT() для числовых полей в качестве разделителей ставит запятые.
*--------------------------------------------------------------------------------------------
* Ver 1.0 - 2010 г.
*--------------------------------------------------------------------------------------------
* Генератор предназначен для получения RTF отчетов без использования WORD а также текстовых
* отчетов с заданной структурой (например, XML или HTML). Имеет гибкую структуру,
* позволяющую последовательно добавлять неограниченное количество таблиц. Также можно вложить таблицу
* в контейнер и размножить ее по количеству записей в таблице контейнера. Скорость генерации - 5-50
* листов в секунду.
*
* Подключать необходимо либо по SET PROC, либо выполнять как DO - см. приложенную форму.
*
* @ Разработчик: TAS - Тимошенко Аскольд Сергеевич
* С вопросами и предложениями обращаться на E-Mail: tascold@mail.ru
* Данное решение находится на сайте http://www.foxclub.ru/sol/solution666.php в разделе решения с наименованием: Advanced RTF Report
*--------------------------------------------------------------------------------------------
* Ver 1.1 - 2010 г.
*--------------------------------------------------------------------------------------------
*  1. ADD: Добавлена возможность обратной сортировки, для этого конструкцию "ORD=выражение" писать
*           как "ORD=DESC:выражение"
*  2. ADD: Добавлен показ % выполнения формирования разделов отчета
*  3. ADD: Добавлена возможность замены русских букв на HEX-коды при обработке символьных переменных
*--------------------------------------------------------------------------------------------
* Ver 1.2 - 2010 г.
*--------------------------------------------------------------------------------------------
*  1. ADD: Добавлены теги CASE, OTHERWISE, ENDCASE
*  2. ADD: Добавлен предварительный подсчет кол-ва разделов и вывод в градуснике "*** из ***"
*  3. IZM: Изменен метод запуска готового файла на WScript
*--------------------------------------------------------------------------------------------
* Ver 1.3 - 2010 г.
*--------------------------------------------------------------------------------------------
*  1. ADD: Добавлена возможность вывода в отчет PNG файлов (конструкция IMG: в описании символьных переменных)
*  2. ADD: Для картинок (переменных с IMG:) можно задавать 3 типа рамки: RM1-простая рамка,RM2-рамка
*           с тенью,RM3-двойная рамка
*  3. ADD: Добавлена возможность разделения разрядов при обработке числовых переменных (конструкция RAZ:)
*  4. ADD: Добавлен вывод ДА/НЕТ при обработке логических переменных (конструкция LRU:)
*--------------------------------------------------------------------------------------------
* Ver 1.4 - 2010 г.
*--------------------------------------------------------------------------------------------
*  1. ERR: Исправлена неадекватная работа счетчика str_tbl (не сбрасывался на 0 при смене таблицы)
*  2. ERR: Исправлен рабочий алиас заголовка и подвала контейнера (переменные не отрабатывались
*           правильно без явного указания алиаса контейнера)
*  3. ADD: Добавлена возможность задавать условие в теге [ALI] как USL$выражение для поиска по списку.
*           Условием для добавления записей в таблицу, находящуюся в группе, в этом случае является:
*           выражение IN (ключ), т.е. ключ должен быть вида "1,2,3" или "'AA','BB','CC'".
*--------------------------------------------------------------------------------------------
* Ver 1.5 - 2010 г.
*--------------------------------------------------------------------------------------------
*  1. ADD: Добавлена возможность задавать подстановки для переменных (конструкция REPVAR*:) Потом доступно
*           использование в переменных вида [&*], где * - ID подстановки). Переменная наследует все функции
*           подстановки, при этом функции переменной приоритетней функций подстановки.
*  2. IZM  Ранее переменные переводились UPPER() теперь этого не делается.  Это сделано для того, чтобы переменные вида
*           ["Дата:"+DTOC(DATE())] выводились в виде "Дата:..." а не "ДАТА:...". Индексы, условия,
*           группировки и сортировки остались регистронезависимыми (переводятся в UPPER() перед обработкой)!
*--------------------------------------------------------------------------------------------
* Ver 1.6 - 2010 г.
*--------------------------------------------------------------------------------------------
*  1. ADD: Добавлен параметр [ADDF] в конфигурации запуска для подавления ошибки создания выходного файла. В случае,
*           если файл результата не может быть перезаписан, добавляет к имени файла "_N", где N может быть от 1 до 49 и
*           пытается записать с новым именем. При достижении N=50, формирует ошибку доступа к диску.
*  2. ADD: Добавлена возможность вывода в отчет JPG файлов.
*--------------------------------------------------------------------------------------------
* Ver 2.0 - 2010 г.
*--------------------------------------------------------------------------------------------
*  ВНИМАНИЕ! VER 2.0 НЕСОВМЕСТИМА С ПРЕДЫДУЩИМИ ВЕРСИЯМИ В ПЛАНЕ СЧЕТЧИКОВ И АЛИАСОВ ГРУПП!!!
*--------------------------------------------------------------------------------------------
*  1. ADD: Добавлена возможность добавлять подгруппы. Подгруппы объявляются также как и группы.
*      МАХ вложенность групп=6.
*  2. IZM: Полностью изменен подход к счетчикам, теперь их стало 72 штуки.
*  3. IZM: Алиас группы изменился с GRP на GR1,GR2,GR3... - в зависимости от вложенности
*--------------------------------------------------------------------------------------------
* Ver 2.1 - 2010 г.
*--------------------------------------------------------------------------------------------
*  1. ERR: Поправлен счетчик [tbl_str] (в некоторых случаях считал неверно)
*  2. ERR: Исправлена ошибка обработки файлов у которых внутренние шрифты указаны без кодировки.
*  3. ADD: Добавлена функция форматирования "BLZ" - выводит число 1000000 как 1 000 000, разделяя разряды пробелами,
*      при этом если число=0, то не выводит ничего.
*  4. ADD: Добавлена функция форматирования "BLK" - если число=0, то не выводит ничего.
*  5. ADD: Добавлен параметр [HIDE] в конфигурации запуска для подавления сообщений процесса генерации
*--------------------------------------------------------------------------------------------
* Ver 2.2 - 2010 г.
*--------------------------------------------------------------------------------------------
*  1. ERR: Поправлены косяки с подстановками в переменных. (Для ряда функций брались не те данные)
*  2. ADD: В целях унификации шаблонов добавлена подстановка "&" при описании контейнеров, таблиц или групп.
*           Пример использования [REP:ALI=&myalias|ORD=&myorder] - здесь в "ALI=&myalias" - "&" - признак подстановки,
*           "myalias" - переменная, которая содержит значения алиаса. Так же и для сортировки.
*           Переменные "myalias" и "myorder" должны быть описаны до запуска генератора!
*      Подстановка может быть использована для любой секции и позволит многократно использовать один и
*           тот же шаблон для схожих по структуре данных.
*  3. ADD: Добавлена функция преобразования "RD3" - округление до 3 знаков после запятой.
*  4. ADD: Добавлена пользовательская функция форматирования переменных: конструкция "FUN=USERFUNC" или
*           "FUN=USERFUNC(m.znh_now)". Если нужно в вашу функцию передать более одного значения, то для передачи
*           текущего значения поля нужно пользоваться переменной m.znh_now.Если параметр только один, то задавать
*           его не нужно - будет автоматически добавлено к имени функции концовка "(m.znh_now)"!
*           Эта конструкция разделяется двоеточием от остальных функций. Выполняется после всех преобразований,
*           при этом имейте ввиду, что тип переменной m.znh_now в момент запуска пользовательской функции, всегда
*           символьный! На выходе также ожидается значение символьного типа!
*--------------------------------------------------------------------------------------------
* Ver 2.3 - 2010 г.
*--------------------------------------------------------------------------------------------
*  1. ERR: Поправлен подвал группировок и ссылки на другие группы. (Теперь в алиасе, на который ссылается
*           переменная, указатель записи из EOF() переводится на BOTTOM).
*  2. ERR: Исправлена ошибка с ограничением до 3, распознавания секций в описании переменных. В связи с этим
*           часть ф-й могли не распознаться. (Теперь увеличено до 10)
*  3. IZM: Теперь концовка к имени пользовательской функции форматирования переменных добавляется не "(m.znh_now)"
*           a "(m.znh_val)". Проверьте свои шаблоны!
*  4. ADD: Добавлена переменная ZNH_VAL с вычисленным, но не преобразованным значением для использования во внешних
*           функциях. Тип переменной ZNH_VAL тот, который имеет поле (выражение) в источнике.
*           ВНИМАНИЕ! Если вы используете внешнюю функцию с переменной ZNH_VAL, то функции преобразования и
*           форматирования задавать бессмысленно!
*  5. ADD: Добавлена переменная ZNH_CON с вычисленным и преобразованным но не отформатированным значением
*           для использования во внешних функциях. Тип переменной ZNH_CON тот, который имеет который имеет
*           функция преобразования на выходе.
*           ВНИМАНИЕ! Если вы используете внешнюю функцию с переменной ZNH_CON, то функции форматирования
*           задавать бессмысленно!
*--------------------------------------------------------------------------------------------
* Ver 2.4 - 2010 г.
*--------------------------------------------------------------------------------------------
*  1. ERR: Исправлена ошибка с длинными путями при показе готового отчета (теперь полное имя файла оборачивается в кавычки)
*  2. ADD: Добавлен параметр [PRINT] или [PRINT=имя_принтера] в конфигурации запуска для печати отчета без просмотра.
*      После знака равенства можно задать целевой принтер.
*  3. ADD: Добавлен параметр [COPIES=*] для печати * копий отчета. Актуально только совместно с [PRINT]
*  4. ADD: Добавлен параметр [PAGES=1,2,5-8] для печати заданных страниц | [PAGES=BOOK] для формирования книжки  | [PAGES=SIDE] - для печати четных и нечетных страниц
*      Актуально только совместно с [PRINT]
*--------------------------------------------------------------------------------------------
* Ver 2.5 - 2011 г.
*--------------------------------------------------------------------------------------------
*  1. ADD: Добавлен параметр [MERGE] - Позволяет объединять текущий результат с существующим файлом WORD.
*  2. IZM: Тег [ENDPAGE] теперь не срабатывает на последних записях текущей таблицы
*  3. ADD: У тега [ENDPAGE] добавлена возможность задавать условие срабатывания: конструкция USL=выражение (задается через разделитель "|")
*  4. ADD: Добавлена пост обработка полученного файла (параметр [FORMAT]): обновление оглавления, если оно есть (только если установлен MS Office)
*  5. IZM: Оптимизация ввода/вывода. Существенное ускорение разборки шаблонов отчетов.
*  6. ADD: Добавлена функция форматирования "TDT" – преобразует DATETIME значение в тип DATE.
*  7. ERR: Исправлена ошибка исполнения условий объектов в безалиасной зоне.
*--------------------------------------------------------------------------------------------
* Ver 2.6 - 2013 г.
*--------------------------------------------------------------------------------------------
*  Добавлена функция SPLIT_REPORT(), надстройка над RTF_REPORT() - дает возможность разделения отчета на несколько файлов. Здесь и далее будут
*  использоваться ссылки, для привязки изменений к конкретной функции.
*  [1] - изменения для функции RTF_REPORT()
*  [2] - изменения для функции SPLIT_REPORT()
*--------------------------------------------------------------------------------------------
*  1. [1].ADD: Генератор можно использовать для формирования текстовых (HTML и XML) отчетов.
*  2. [1].ERR: Исправлена ошибка применения условия таблицы, заданной вне контейнера
*  3. [1].ADD: Добавлен параметр [COD=N] - Позволяет записывать данные поля в перекодированном виде. Варианты N см. в параметрах ф-и STRCONV()
*        Параметр [COD] имеет более высокий приоритет, чем параметр [ENCODE].
*  4. [1].ADD: Добавлен параметр [ENCODE=N] - Позволяет записывать все данные отчета в перекодированном виде. Варианты N см. в параметрах ф-и STRCONV()
*        (Например, есть шаблон в кодировке 1251, необходимо сохранить XML файл в кодировке utf-8).
*  5. [2].ADD: Добавлена функция SPLIT_REPORT(), надстройка над RTF_REPORT() - дает возможность разделения отчета на несколько файлов.
*  6. [2].ADD: Добавлен ОБЯЗАТЕЛЬНЫЙ параметр [SPLIT=*] - где "*" - MAX количество записей в томе.
*  7. [2].ADD: Добавлен параметр [STOMS=1,2,5-8] для формирования только указанных томов.
*--------------------------------------------------------------------------------------------
* Ver 2.7 - 2015 г.
*--------------------------------------------------------------------------------------------
*  1. [1].ADD: Добавлена функция преобразования "PAR" - для добавления текста содержащего несколько строк в виде отдельных параграфов. Актуально только для RTF файла.
*--------------------------------------------------------------------------------------------
* Ver 2.8 - 2018 г.
*--------------------------------------------------------------------------------------------
*  1. [1].ERR: Добавлена проверка длины наименования функции преобразования, чтобы исключить их срабатывание при похожем начале имени переменной и установкой SET EXACT OFF.
*  2. [1].ADD: Добавлена функция преобразования "ML5" - масштабирование (уменьшение) картинки на 50% (актуально только для конструкции "IMG").
*--------------------------------------------------------------------------------------------
* Ver 2.9 - 2018 г.
*--------------------------------------------------------------------------------------------
*  1. [1].IZM: Более чем в 2 раза ускорена функция разборки шаблона READ_RTF().
*--------------------------------------------------------------------------------------------
* Ver 3.0 - 2019 г.
*--------------------------------------------------------------------------------------------
*  Добавлена функция XLS_REPORT, надстройка над RTF_REPORT() для формирования отчетов в EXCEL с использованием XML шаблонов.
*   Добавлена функция DBF_TOEXCEL - продвинутая выгрузка данных курсора в EXCEL. Может использоваться отдельно.
*  [1] - изменения для функции RTF_REPORT()
*  [2] - изменения для функции SPLIT_REPORT()
*  [3] - изменения для функции XLS_REPORT()
*  [4] - изменения для функции DBF_TOEXCEL()
*--------------------------------------------------------------------------------------------
*  1. [1].ADD: Добавлена поддержка выгрузки в EXCEL.
*  2. [3].ADD: Добавлена функции XLS_REPORT().
*  3. [4].ADD: Добавлена функции DBF_TOEXCEL().
*--------------------------------------------------------------------------------------------
* Ver 3.1 - 2019 г.
*--------------------------------------------------------------------------------------------
*  1. [1].IZM: Добавлена функция преобразования "NUM" - для приведения типа ячейки к числовому формату (актуально только для формирования отчетов в EXCEL).
*--------------------------------------------------------------------------------------------
If Vartype(m.rep_config)#"C"
  rep_config=''
Endif
f_shabl = Alltrim(m.f_shabl)
Local i,form_ret,file_nom,file_name,f_printer,f_pcopies,f_conftxt,openword,loWord,file_id
Private f_out,rep_errs,proc_all,proc_now,proc_kol,proc_rzd,proc_lvl,proc_glv,alias_in,reps_cod
rep_errs=''  && переменная для ошибки
proc_all=0  && всего шагов для текущего proc_rzd
proc_now=0  && текущий шаг
proc_kol=0  && кол-во %
proc_rzd=0  && раздел
proc_lvl=0  && уровень 1-контейнер, 2-группа, 3-строка
reps_cod=0  && перекодировка файла
alias_in=Alias()  && текущий алиас
For i=1 To Getwordcount(m.rep_config,"]")
  f_conftxt=Alltrim(Getwordnum(m.rep_config,m.i,"]"))
  Do Case
  Case Alltrim(Upper(Left(m.f_conftxt,8)))=="[ENCODE="
    reps_cod=Val(Substr(m.f_conftxt,At("=",m.f_conftxt)+1))
    reps_cod=Iif(Between(m.reps_cod,1,16),m.reps_cod,0)
  Endcase
Endfor
*--------------------------------------------------------------------------------------------
* загрузка структуры
*--------------------------------------------------------------------------------------------
Wait Window Iif("[HIDE]"$Upper(m.rep_config),"","Идет загрузка структуры") Nowait Noclear
*aaa=SECONDS()
form_ret=READ_RTF(m.f_shabl)  && формирование струтуры
*WAIT WINDOW STR(SECONDS()-aaa,10,2)
*--------------------------------------------------------------------------------------------
* генерация отчета
*--------------------------------------------------------------------------------------------
file_nom=0      && для № файла
file_name=m.f_othet  && запоминается оригинальное имя файла
If m.form_ret=1
  proc_glv=GET_RAZDKOL()  && получение количества независимых разделов в шаблоне
  Do While .T.
    If "[MERGE]"$Upper(m.rep_config) And File(m.f_othet)
      rep_config=Strtran(m.rep_config,"[ADDF]","")
      m.f_othet=Sys(2023)+"\"+Sys(2015)+".rtf"  && временное имя файла
    Endif
    f_out = Fcreate(m.f_othet)
    Do Case
    Case m.f_out<0 And "[ADDF]"$Upper(m.rep_config)
      If m.file_nom<50
        file_nom=m.file_nom+1
        f_othet=Addbs(Justpath(m.file_name))+Juststem(m.file_name)+"_"+Alltrim(Str(m.file_nom))+"."+Justext(m.file_name)
      Else
        rep_errs='Ошибка создания выходного файла! Проверьте наличие доступа к папке: '+Addbs(Justpath(m.file_name))
        form_ret=-1
        Exit
      Endif
    Case m.f_out<0
      rep_errs='Ошибка создания выходного файла! Возможно этот файл открыт в WORD?'
      form_ret=-1
      Exit
    Otherwise
      form_ret=ADD_REP()        && формирование тела файла
      =Fclose(m.f_out)
      Exit
    Endcase
  Enddo
Endif
*--------------------------------------------------------------------------------------------
* объединение полученного результата с существующим файлом по опции [MERGE]
*--------------------------------------------------------------------------------------------
If m.form_ret=1 And "[MERGE]"$Upper(m.rep_config) And File(m.f_othet)
  Wait Window Iif("[HIDE]"$Upper(m.rep_config),"","Идет объединение файлов...") Nowait Noclear
  openword=0
  file_id=Fopen(m.file_name,12)
  If m.file_id<=0  && файл не удалось открыть на запись
    form_ret=-1
    rep_errs='Ошибка объединения полученного результата с существующим файлом! Возможно этот файл открыт в WORD?'
  Else
    =Fclose(m.file_id)
    Try
      loWord=Createobject('Word.Application')
      With loWord
        .Visible=.F.
        openword=1          && добрались до этой строки - значит будем закрывать WORD при завершении
        loBook = .Documents.Open(Fullpath(m.file_name))
        .ActiveDocument.Range.Select
        With .Selection
          .EndKey(6)
          .TypeParagraph        && добавляем новый параграф с очищенным форматированием
          .ClearFormatting
          .InsertBreak(2)
          .InsertFile(Fullpath(m.f_othet))
          .HomeKey(6)
        Endwith
        .DisplayAlerts = 0
        .ActiveDocument.Save()
        .Quit(0)
      Endwith
      loWord = Null
      Delete File (m.f_othet)  && удаляем временный файл
      f_othet=m.file_name
    Catch To goto_error
      rep_errs='Ошибка объединения полученного результата с существующим файлом! Возможно этот файл открыт в WORD?'
      form_ret=-1
      If m.openword=1
        loWord.Quit(0)
        loWord=.Null.
      Endif
    Endtry
  Endif
Endif
*--------------------------------------------------------------------------------------------
* Обновление оглавления (если есть)
*--------------------------------------------------------------------------------------------
If m.form_ret=1 And "[FORMAT]"$Upper(m.rep_config)
  Wait Window Iif("[HIDE]"$Upper(m.rep_config),"","Идет форматирование...") Nowait Noclear
  Try
    openword=0
    loWord=Createobject('Word.Application')
    With loWord
      .Visible=.F.
      openword=1          && добрались до этой строки - значит будем закрывать WORD при завершении
      loBook = .Documents.Open(Fullpath(m.file_name))
      With loBook
        If .TablesOfContents.Count>0      && если есть оглавление
          .TablesOfContents.Item(1).Update  && то обновляем его
        Endif
      Endwith
      .DisplayAlerts = 0
      .ActiveDocument.Save()
    Endwith
  Catch To goto_error
  Endtry
  If m.openword=1
    loWord.Quit(0)
    loWord=.Null.
  Endif
Endif
If "[HIDE]"$Upper(m.rep_config)=.F.
  Wait Clear
Endif
*--------------------------------------------------------------------------------------------
* запуск просмотра готового файла
*--------------------------------------------------------------------------------------------
If m.form_ret=1
  Do Case
  Case "[SHOW]"$Upper(m.rep_config)  && Показать отчет
    WSHShell=Createobject("WScript.Shell",0,.F.)
    WSHShell.Run('"'+m.f_othet+'"')
  Case "[PRINT"$Upper(m.rep_config)  && Печать
    f_printer=''
    f_pcopies=1
    f_pages=''
    For i=1 To Getwordcount(m.rep_config,"]")
      f_conftxt=Alltrim(Getwordnum(m.rep_config,m.i,"]"))
      Do Case
      Case Alltrim(Upper(Left(m.f_conftxt,7)))=="[PRINT="
        f_printer=Alltrim(Substr(m.f_conftxt,At("=",m.f_conftxt)+1))
      Case Alltrim(Upper(Left(m.f_conftxt,8)))=="[COPIES="
        f_pcopies=Val(Substr(m.f_conftxt,At("=",m.f_conftxt)+1))
      Case Alltrim(Upper(Left(m.f_conftxt,7)))=="[PAGES="
        f_pages=Substr(m.f_conftxt,At("=",m.f_conftxt)+1)
      Endcase
    Endfor
    Wait Window Iif("[HIDE]"$Upper(m.rep_config),"","Идет печать документа...") Nowait Noclear
    If PrintAny(m.f_othet,m.f_printer,m.f_pcopies,m.f_pages)<=0
      rep_errs='Ошибка при печати WORD документа!'
    Endif
    If "[HIDE]"$Upper(m.rep_config)=.F.
      Wait Clear
    Endif
  Endcase
Endif
*--------------------------------------------------------------------------------------------
Use In Select('_rtfreport')
Use In Select('_rtftables')
Use In Select('_rtfvables')
If !Empty(m.alias_in) And Used(m.alias_in)
  Select (m.alias_in)
Endif
Return m.rep_errs   && пустая, если все ОК!
*############################################################################################
*############################################################################################
*############################################################################################
Function ADD_REP  && головная ф-я формирования выходного файла
Local rep_okey,tbl_alia
*--------------------------------------------------------------------------------------------
* Переменные для счетчиков
*--------------------------------------------------------------------------------------------
Dimension rep_shet(72)  && массив счетчиков
Private rep_con,rep_tbl,rep_gr1,rep_gr2,rep_gr3,rep_gr4,rep_gr5,rep_gr6,rep_str
Private con_all,con_now,con_str,con_tbl,con_gr1,con_gr2,con_gr3,con_gr4,con_gr5,con_gr6
Private tbl_all,tbl_now,tbl_str,tbl_gr1,tbl_gr2,tbl_gr3,tbl_gr4,tbl_gr5,tbl_gr6,tbl_kol
Private gr1_all,gr1_now,gr1_str,gr1_gr2,gr1_gr3,gr1_gr4,gr1_gr5,gr1_gr6,gr1_kol,gr1_tek
Private gr2_all,gr2_now,gr2_str,gr2_gr3,gr2_gr4,gr2_gr5,gr2_gr6,gr2_kol,gr2_tek
Private gr3_all,gr3_now,gr3_str,gr3_gr4,gr3_gr5,gr3_gr6,gr3_kol,gr3_tek
Private gr4_all,gr4_now,gr4_str,gr4_gr5,gr4_gr6,gr4_kol,gr4_tek
Private gr5_all,gr5_now,gr5_str,gr5_gr6,gr5_kol,gr5_tek
Private gr6_all,gr6_now,gr6_tek
rep_shet=0        && обнуление массива счетчиков
Store 0 To rep_con,rep_tbl,rep_gr1,rep_gr2,rep_gr3,rep_gr4,rep_gr5,rep_gr6,rep_str
Store 0 To con_all,con_now,con_str,con_tbl,con_gr1,con_gr2,con_gr3,con_gr4,con_gr5,con_gr6
Store 0 To tbl_all,tbl_now,tbl_str,tbl_gr1,tbl_gr2,tbl_gr3,tbl_gr4,tbl_gr5,tbl_gr6,tbl_kol
Store 0 To gr1_all,gr1_now,gr1_str,gr1_gr2,gr1_gr3,gr1_gr4,gr1_gr5,gr1_gr6,gr1_kol,gr1_tek
Store 0 To gr2_all,gr2_now,gr2_str,gr2_gr3,gr2_gr4,gr2_gr5,gr2_gr6,gr2_kol,gr2_tek
Store 0 To gr3_all,gr3_now,gr3_str,gr3_gr4,gr3_gr5,gr3_gr6,gr3_kol,gr3_tek
Store 0 To gr4_all,gr4_now,gr4_str,gr4_gr5,gr4_gr6,gr4_kol,gr4_tek
Store 0 To gr5_all,gr5_now,gr5_str,gr5_gr6,gr5_kol,gr5_tek
Store 0 To gr6_all,gr6_now,gr6_tek
*--------------------------------------------------------------------------------------------
rep_okey=1
tbl_alia=GET_REPALIAS("[REP]")
Select * From _rtfreport Where !Inlist(obtype,3,4,5,6,9,12,13,14,15) And Empty(rodrid) Into Cursor (m.tbl_alia) Readwrite
Scan      && 1 раз по каждому разделу верхнего уровня кроме группировок и детайл
  proc_lvl=0  && сброс уровня отображения % в начале каждого раздела
  Do Case
  Case obtype=2
    rep_okey=ADD_TBL(rnomer,tnomer,grnext,grpend)  && отвечает также за добавление 3,4,5,6
  Case obtype=10
    rep_okey=ADD_CON(rnomer,tnomer,rid)  && отвечает также за добавление всего, что внутри для текущего RID
  Otherwise
    rep_okey=ADD_STR(rnomer,rztype,Iif(Seek(tnomer,"_rtftables","k1"),Alltrim(_rtftables.ALINOW),m.alias_in))
  Endcase
  If m.rep_okey<=0
    Exit
  Endif
Endscan
Use In (m.tbl_alia)
Return m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
Function GET_RAZDKOL  && получение количества независимых разделов в шаблоне
Local razd_kol,razd_con
razd_kol=0
razd_con=0
Select _rtfreport
Scan For Inlist(obtype,2,10,11)    && контейнеры и таблицы
  razd_con=Icase(obtype=10,1,obtype=11,0,m.razd_con)
  Do Case
  Case obtype=10          && начинается контейнер
    razd_kol=m.razd_kol+1
  Case obtype=2 And m.razd_con=0  && начинается таблица, при условии, что она не в контейнере
    razd_kol=m.razd_kol+1
  Endcase
Endscan
Return m.razd_kol
*############################################################################################
*############################################################################################
*############################################################################################
Function ADD_CON  && добавление контейнера
Lparameters t_rnomer,t_anomer,t_rid
* t_rnomer   - номер раздела
* t_anomer   - номер алиаса
* t_rid    - ID раздела текущего контейнера
*--------------------------------------------------------------------------------------------
Local tbl__ali,tbl__key,ali_now,tbl__ord,tbl__des,rep_okey,key_data,ali_con
=Seek(m.t_anomer,"_rtftables","k1")
tbl__ali=Alltrim(_rtftables.ALINOW)
tbl__key=Alltrim(_rtftables.ALIKEY)
tbl__ord=Alltrim(_rtftables.ALIORD)
tbl__des=_rtftables.ALIDES
ali_now=GET_REPALIAS("[CON]")  && алиас с данными по контейнеру для цикла
ali_con=GET_REPALIAS("[RZD]")  && алиас с разделами для обработки
tbl__key=Iif(Empty(m.tbl__key),"1=1",GET_FUNCONV(m.tbl__key))
tbl__ord=Iif(Empty(m.tbl__ord),"1",m.tbl__ord)
*--------------------------------------------------------------------------------------------
TEXT TO tempusl NOSHOW TEXTMERGE PRETEXT 7
    SELECT <<m.tbl__ord>> AS order_fld,* ;
    FROM <<m.tbl__ali>> ;
    ORDER BY 1 <<IIF(m.tbl__des=1,"DESC","")>> ;
    INTO CURSOR <<m.ali_now>> READWRITE
ENDTEXT
rep_okey=1
Try
  =Execscript(m.tempusl)
Catch
  rep_okey=0
  rep_errs='Не удалось получить данные для отчета!'
Endtry
If m.rep_okey=1
  =RUN_SHET(1,0)        && инициализация счетчиков по контейнеру
  Select * From _rtfreport Where rodrid=m.t_rid And Inlist(obtype,2,7) Into Cursor (m.ali_con) Readwrite
*--------------------------------------------------------------------------------------------
* Формирование % выполнения
*--------------------------------------------------------------------------------------------
  proc_lvl=1          && уровень 1-контейнер, 2-группа, 3-строка
  proc_all=con_all      && всего шагов для текущего proc_rzd
  proc_now=0          && текущий шаг %
  proc_kol=0          && кол-во %
  proc_rzd=m.proc_rzd+1    && раздел
  Select (m.ali_now)
  Scan
    =RUN_SHET(1,1)      && отработка счетчиков по контейнеру
    proc_now=m.proc_now+1  && текущий шаг %
    =SHOW_PROC()      && показ % выполнения
*--------------------------------------------------------------------------------------------
* Формирование заголовка контейнера
*--------------------------------------------------------------------------------------------
    If m.rep_okey=1
      rep_okey=ADD_STR(m.t_rnomer,10,m.ali_now)
    Endif
*--------------------------------------------------------------------------------------------
    Select (m.ali_now)
    Try
      key_data=Evaluate(m.tbl__key)  && ключевое значение для выборки данных из таблицы
    Catch
      rep_okey=0
      rep_errs='Неверно задано ключевое выражение при описании контейнера!'
    Endtry
    If m.rep_okey=1
      Select (m.ali_con)  && верхний уровень в контейнере - начало и конец таблиц
      Scan
        Do Case
        Case obtype=2
          rep_okey=ADD_TBL(rnomer,tnomer,grnext,grpend,m.key_data,m.ali_now)  && отвечает также за добавление 3,4,5,6
        Otherwise
          rep_okey=ADD_STR(rnomer,rztype,m.ali_now)
        Endcase
        If m.rep_okey<=0
          Exit
        Endif
      Endscan
    Endif
    If rep_okey#1
      Exit
    Endif
  Endscan
Endif
*--------------------------------------------------------------------------------------------

Use In Select(m.ali_con)
Use In Select(m.ali_now)
Return m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
Function ADD_TBL  && добавление таблицы
Lparameters t_rnomer,t_anomer,t_grnext,t_tblend,t_keydata,t_keyalia
* t_rnomer   - номер раздела
* t_anomer   - номер алиаса
* t_grnext  - номер раздела группы таблицы
* t_tblend  - номер раздела подвала таблицы
* t_keydata  - ключевое значение для выборки данных из таблицы
* t_keyalia  - алиас с данными для получения значения ключа
*--------------------------------------------------------------------------------------------
Local rep_okey,tbl__ali,ali__grp,ali__now,tbl__add,ali__dat,tbl__dtl,grp_head
=Seek(m.t_anomer,"_rtftables","k1")
tbl__ali=Alltrim(_rtftables.ALINOW)
ali__now=GET_REPALIAS("[TBL]")
ali__grp=GET_REPALIAS("[GZ1]")
ali__dat=GET_REPALIAS("[GR1]")
tbl__add=_rtftables.ALIADD
*--------------------------------------------------------------------------------------------
* Получение курсоров данных таблицы и заголовков групп
*--------------------------------------------------------------------------------------------
rep_okey=GET_TBLDATA(m.t_anomer,m.t_keydata,m.t_keyalia)
*--------------------------------------------------------------------------------------------
* Формирование заголовка таблицы
*--------------------------------------------------------------------------------------------
If m.rep_okey=1
  =RUN_SHET(2,0)  && инициализация счетчиков по таблице
  =RUN_SHET(2,1)  && отработка счетчиков по таблице
  If m.tbl_all>0 Or m.tbl__add=1  && если есть хоть 1 запись или указано выдавать и пустую
    rep_okey=ADD_STR(m.t_rnomer,2,m.tbl__ali)  && заголовок таблицы
    If m.rep_okey=1
      If Seek(Str(m.t_anomer,10)+Str(4,2),"_rtfreport","k3")  && ищем раздел для detail этой таблицы
        tbl__dtl=_rtfreport.rnomer    && раздел detail
      Endif
      If m.t_grnext>0    && есть группы у этой таблицы
        rep_okey=GET_GRPTITL(m.t_anomer,1)        && курсор с заголовками для группы 1 уровня
*--------------------------------------------------------------------------------------------
* Формирование % выполнения
*--------------------------------------------------------------------------------------------
        If m.rep_okey=1
          If Inlist(m.proc_lvl,0,2) And Reccount(m.ali__grp)>1  && всего групп у таблицы>1
            proc_lvl=2                && уровень 1-контейнер, 2-группа, 3-строка
            proc_all=Reccount(m.ali__grp)      && всего шагов для текущего proc_rzd
            proc_now=0                && текущий шаг %
            proc_kol=0                && кол-во %
            proc_rzd=m.proc_rzd+1          && раздел
          Endif
*--------------------------------------------------------------------------------------------
* Формирование групп таблицы
*--------------------------------------------------------------------------------------------
          =RUN_SHET(3,0)        && инициализация счетчиков по группе 1 уровня
          Select (m.ali__grp)
          Scan
            rep_okey=GET_GRPDATA(m.t_anomer,1,grp_dat)  && курсор с данными для группы 1 уровня
            If m.rep_okey=1
              =RUN_SHET(3,1)            && отработка счетчиков по группе 1 уровня
              Do Case
              Case m.proc_lvl=2
                proc_now=m.proc_now+1      && текущий шаг %
                =SHOW_PROC()          && показ % выполнения
              Case Inlist(m.proc_lvl,0,3)
                proc_lvl=3            && уровень 1-контейнер, 2-группа, 3-строка
                proc_all=Reccount(m.ali__now)  && всего шагов для текущего proc_rzd
                proc_now=0            && текущий шаг %
                proc_kol=0            && кол-во %
                proc_rzd=m.proc_rzd+1      && раздел
              Endcase
              rep_okey=ADD_GRP(m.t_anomer,1,m.ali__dat,m.t_grnext,m.tbl__dtl)  && для каждой группы по текущей таблице
            Endif
            If m.rep_okey#1
              Exit
            Endif
          Endscan
        Endif
*--------------------------------------------------------------------------------------------
* Формирование строчек таблицы
*--------------------------------------------------------------------------------------------
      Else
        If Inlist(m.proc_lvl,0,3)
          proc_lvl=3            && уровень 1-контейнер, 2-группа, 3-строка
          proc_all=Reccount(m.ali__now)  && всего шагов для текущего proc_rzd
          proc_now=0            && текущий шаг %
          proc_kol=0            && кол-во %
          proc_rzd=m.proc_rzd+1      && раздел
        Endif
        rep_okey=ADD_STRALIA(m.ali__now,m.tbl__dtl)
      Endif
    Endif
*--------------------------------------------------------------------------------------------
* Формирование подвала таблицы
*--------------------------------------------------------------------------------------------
    If m.rep_okey=1 And !Empty(m.t_tblend)
      rep_okey=ADD_STR(m.t_tblend,6,m.tbl__ali)
    Endif
  Endif
Endif
*--------------------------------------------------------------------------------------------
Use In Select(m.ali__dat)
Use In Select(m.ali__grp)
Use In Select(m.ali__now)
Return m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
Function ADD_GRP  && добавление группы
Lparameters t_anomer,grp_level,grp_alias,grp_head,tbl__dtl
* t_anomer   - номер алиаса
* grp_level  - уровень вложенности
* grp_alias - алиас с данными
* grp_head  - номер раздела головы группы
* tbl__dtl  - номер раздела DETAIL таблицы
*--------------------------------------------------------------------------------------------
Local rep_okey,ali__dat,grp__ttl,grp__end,grp__nxt
ali__dat=GET_REPALIAS("[GR"+Alltrim(Str(m.grp_level+1))+"]")
grp__ttl=GET_REPALIAS("[GZ"+Alltrim(Str(m.grp_level+1))+"]")
*--------------------------------------------------------------------------------------------
* Формирование головы группы
*--------------------------------------------------------------------------------------------
=Seek(m.grp_head,"_rtfreport","k5")
grp__end=_rtfreport.grpend  && RID хвоста группы
grp__nxt=_rtfreport.grnext  && RID подгруппы
rep_okey=ADD_STR(m.grp_head,3,m.grp_alias)
If m.rep_okey=1
*--------------------------------------------------------------------------------------------
* Формирование подгрупп группы
*--------------------------------------------------------------------------------------------
  If m.grp__nxt>0    && есть подгруппы
    rep_okey=GET_GRPTITL(m.t_anomer,m.grp_level+1)          && курсор с заголовками для группы N+1 уровня
    =RUN_SHET(3+m.grp_level,0)                    && инициализация счетчиков по группе N+1 уровня
    Select (m.grp__ttl)
    Scan
      rep_okey=GET_GRPDATA(m.t_anomer,m.grp_level+1,grp_dat)    && курсор с данными для группы N+1 уровня
      If m.rep_okey=1
        =RUN_SHET(3+m.grp_level,1)                && отработка счетчиков по группе N+1 уровня
        rep_okey=ADD_GRP(m.t_anomer,m.grp_level+1,m.ali__dat,m.grp__nxt,m.tbl__dtl)  && для каждой группы по текущей таблице
      Endif
      If m.rep_okey#1
        Exit
      Endif
    Endscan
*--------------------------------------------------------------------------------------------
* Формирование строчек группы
*--------------------------------------------------------------------------------------------
  Else
    rep_okey=ADD_STRALIA(m.grp_alias,m.tbl__dtl)
  Endif
Endif
*--------------------------------------------------------------------------------------------
* Формирование подвала группы
*--------------------------------------------------------------------------------------------
If m.rep_okey=1 And !Empty(m.grp__end)
  rep_okey=ADD_STR(m.grp__end,3,m.grp_alias)
Endif
*--------------------------------------------------------------------------------------------
Use In Select(m.ali__dat)  && закрываем курсоры N+1 вложенности
Use In Select(m.grp__ttl)  && закрываем курсоры N+1 вложенности
Return m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
Function ADD_STRALIA  && добавление объектов по всем строкам алиаса
Lparameters tek_alias,tbl__dtl
Select (m.tek_alias)
Scan
  RUN_SHET(9,1)        && отработка счетчиков строк
  If m.proc_lvl=3
    proc_now=m.proc_now+1  && текущий шаг %
    SHOW_PROC()      && показ % выполнения
  Endif
  If ADD_STR(m.tbl__dtl,4,m.tek_alias)#1  && для каждой строки по текущей группе
    Return 0
  Endif
Endscan
Return 1
*############################################################################################
*############################################################################################
*############################################################################################
Function ADD_STR  && добавление объектов по разделу
Lparameters t_rnomer,t_rztype,t_alias
* t_rnomer   - номер раздела
* t_rztype  - тип раздела
* t_alias  - surs с данными
*--------------------------------------------------------------------------------------------
Local i,err_now,f_ret
Private tmp_name,tmp_func,ali_func,tmp_fusr,tmp_case,tmp_cusl,tmp_crun,tmp_fend,tmp_fout,znh_now,znh_val,znh_con,tmp_code
tmp_case=0  && ID CASE, объекты которого будут добавлены
Select _rtfreport
Scan For rnomer=m.t_rnomer
  Do Case
  Case obkolv=1  && управляющие теги
    f_ret = Fwrite(m.f_out,beetw_text)  && пишем в вых. файл
    If m.f_ret<0
      rep_errs='Ошибка записи в выходной файл!'
      Return -1
    Endif
  Case obtype=12   && ENDPAGE
    If !Empty(objusl)               && есть условие применения
      If !Empty(m.t_alias)
        Select (m.t_alias)
      Endif
      Try
        tmp_crun=Iif(Evaluate(Alltrim(_rtfreport.objusl)),1,0)
      Catch
        tmp_crun=0    && ошибка задания условия будет проигнорирована так, как будто условие не задавали вовсе
      Endtry
      Select _rtfreport
      If m.tmp_crun=1    && условие выполнено
        f_ret = Fwrite(m.f_out,'\page \par '+beetw_text)  && пишем в вых. файл
      Else
        f_ret = Fwrite(m.f_out,beetw_text)  && пишем в вых. файл
      Endif
    Else
      f_ret = Fwrite(m.f_out,Iif(Recno(m.t_alias)<Reccount(m.t_alias),'\page \par ','')+beetw_text)  && пишем в вых. файл
    Endif
    If m.f_ret<0
      rep_errs='Ошибка записи в выходной файл!'
      Return -1
    Endif
  Case m.tmp_case=0 And Inlist(obtype,13,14)  && CASE,OTHERWISE, заходим вычислить ID CASE, который будет отрабатывать
    tmp_crun=1    && 1-выводить этот CASE
    If obtype=13  && для CASE вычисляем выражение, OTHERWISE проскочит полюбому
      tmp_cusl=Alltrim(Substr(_rtfreport.f_name,At("=",_rtfreport.f_name)+1))  && условие CASE
      tmp_cusl=GET_FUNCONV(m.tmp_cusl)
      If !Empty(m.t_alias)
        Select (m.t_alias)
      Endif
      Try
        tmp_crun=Iif(Evaluate(m.tmp_cusl),1,0)
      Catch
        tmp_crun=0
      Endtry
      Select _rtfreport
    Endif
    If m.tmp_crun=1
      tmp_case=_rtfreport.caseid    && признак выполнения CASE
      f_ret = Fwrite(m.f_out,beetw_text)  && пишем в вых. файл
      If m.f_ret<0
        rep_errs='Ошибка записи в выходной файл!'
        Return -1
      Endif
    Endif
  Case obtype=15  && ENDCASE
    tmp_case=0
    f_ret = Fwrite(m.f_out,beetw_text)  && пишем в вых. файл
    If m.f_ret<0
      rep_errs='Ошибка записи в выходной файл!'
      Return -1
    Endif
  Case !Empty(_rtfreport.caseid) And _rtfreport.caseid#m.tmp_case  && объекты включены в CASE с невыполненным условием
    Loop
  Otherwise
    tmp_name=Alltrim(_rtfreport.f_name)
    If Left(m.tmp_name,1)=="&" And Seek(Val(Substr(m.tmp_name,2)),"_rtfvables","k1")  && нашли эту подстановку
      tmp_name=Alltrim(_rtfvables.f_name)
      tmp_func=Upper(Alltrim(Iif(!Empty(_rtfreport.func_txt),_rtfreport.func_txt,_rtfvables.func_txt)))
      ali_func=Upper(Alltrim(Iif(!Empty(_rtfreport.func_ali),_rtfreport.func_ali,_rtfvables.func_ali)))
      tmp_fusr=Upper(Alltrim(Iif(!Empty(_rtfreport.func_usr),_rtfreport.func_usr,_rtfvables.func_usr)))
      tmp_fend=Upper(Alltrim(Iif(!Empty(_rtfreport.func_end),_rtfreport.func_end,_rtfvables.func_end)))
      tmp_fout=Upper(Alltrim(Iif(!Empty(_rtfreport.func_out),_rtfreport.func_out,_rtfvables.func_out)))
      tmp_code=Iif(!Empty(_rtfreport.code_txt),_rtfreport.code_txt,_rtfvables.code_txt)
    Else
      tmp_func=Upper(Alltrim(_rtfreport.func_txt))
      ali_func=Upper(Alltrim(_rtfreport.func_ali))
      tmp_fusr=Upper(Alltrim(_rtfreport.func_usr))
      tmp_fend=Upper(Alltrim(_rtfreport.func_end))
      tmp_fout=Upper(Alltrim(_rtfreport.func_out))
      tmp_code=_rtfreport.code_txt
    Endif
    If Vartype(m.t_alias)="C" And !Empty(m.t_alias)
      Select (m.t_alias)
      ali_func=Iif(!Empty(m.ali_func),m.ali_func,m.t_alias)
    Endif
    err_now=0
    znh_now=''
    If !Empty(m.t_alias)
      tmp_recn=Iif(Eof(m.t_alias),0,Recno(m.t_alias))  && запоминается текущая запись SURC курсора
    Endif
*--------------------------------------------------------------------------------------------
* Попытка получения значения
*--------------------------------------------------------------------------------------------
    Try
      If Empty(m.tmp_func)
        If !Empty(m.ali_func)
          Select (m.ali_func)
        Endif
        If Eof()  && проверяем, чтобы не было EOF() при обработке переменной
          Go Bottom
        Endif
        znh_now=Evaluate(m.tmp_name)
      Else
        Do Case
        Case m.tmp_func=="SUM"  && требуется посчитать по текущей таблице
          Calculate Sum(&tmp_name) To znh_now In (m.ali_func)
        Case m.tmp_func=="MAX"  && требуется посчитать MAX по текущей таблице
          Calculate Max(&tmp_name) To znh_now In (m.ali_func)
        Case m.tmp_func=="MIN"  && требуется посчитать MIN по текущей таблице
          Calculate Min(&tmp_name) To znh_now In (m.ali_func)
        Case m.tmp_func=="CNT"  && требуется посчитать кол-во по текущей таблице
          Calculate Cnt(&tmp_name) To znh_now In (m.ali_func)
        Case m.tmp_func=="AVG"  && требуется посчитать среднее по текущей таблице
          Calculate Avg(&tmp_name) To znh_now In (m.ali_func)
        Otherwise
          err_now=1
        Endcase
      Endif
      znh_val=m.znh_now  && запоминается вычисленное значение для использования во внешних ф-х
      If !Empty(m.tmp_fusr)
        Do Case
        Case m.tmp_fusr=="DAT" And Inlist(Vartype(m.znh_now),"D","T")
          znh_now=REP_DATAPROP(m.znh_now)
        Case m.tmp_fusr=="TDT" And Vartype(m.znh_now)="T"
          znh_now=Ttod(m.znh_now)
        Case m.tmp_fusr=="PN1" And Inlist(Vartype(m.znh_now),"D","T","C")
          znh_now=REP_PERNAME(m.znh_now)
        Case m.tmp_fusr=="PN2" And Inlist(Vartype(m.znh_now),"D","T")
          znh_now=REP_PERNAME(m.znh_now,"P")
        Case m.tmp_fusr=="PN3" And Inlist(Vartype(m.znh_now),"D","T")
          znh_now=REP_PERNAME(m.znh_now,"Q")
        Case m.tmp_fusr=="PN4" And Inlist(Vartype(m.znh_now),"D","T")
          znh_now=REP_PERNAME(m.znh_now,"H")
        Case m.tmp_fusr=="KOL" And Vartype(m.znh_now)="N"
          znh_now=REP_NUM_PROP(m.znh_now,1)
        Case m.tmp_fusr=="RUB" And Vartype(m.znh_now)="N"
          znh_now=REP_NUM_PROP(m.znh_now)
        Case m.tmp_fusr=="INT" And Vartype(m.znh_now)="N"
          znh_now=Int(m.znh_now)
        Case m.tmp_fusr=="DEC" And Vartype(m.znh_now)="N"
          znh_now=Mod(m.znh_now,1)
        Case m.tmp_fusr=="RD0" And Vartype(m.znh_now)="N"
          znh_now=Round(m.znh_now,0)
        Case m.tmp_fusr=="RD1" And Vartype(m.znh_now)="N"
          znh_now=Round(m.znh_now,1)
        Case m.tmp_fusr=="RD2" And Vartype(m.znh_now)="N"
          znh_now=Round(m.znh_now,2)
        Case m.tmp_fusr=="RD3" And Vartype(m.znh_now)="N"
          znh_now=Round(m.znh_now,3)
        Case m.tmp_fusr=="IMG" And Vartype(m.znh_now)="C"
          If File(m.znh_now)  && если есть этот файл
            Do Case
            Case Upper(Justext(m.znh_now))=="PNG"
              znh_now="{\pict\pngblip "+Strconv(Filetostr(m.znh_now),15)+" }"
            Case Upper(Justext(m.znh_now))=="JPG"
              znh_now="{\pict\jpegblip "+Strconv(Filetostr(m.znh_now),15)+" }"
            Endcase
          Endif
        Case m.tmp_fusr=="PAR" And Vartype(m.znh_now)="C"  && Актуально только для RTF
          znh_now=Strtran(m.znh_now,Chr(13),"{\par }")
        Endcase
      Endif
      znh_con=m.znh_now  && запоминается вычисленное и преобразованное значение для использования во внешних ф-х
    Catch
      err_now=1
    Endtry
    If !Empty(m.t_alias) And !Empty(m.tmp_recn)
      Go m.tmp_recn In (m.t_alias)
    Endif
*--------------------------------------------------------------------------------------------
    If m.err_now=1
      znh_now=Alltrim(_rtfreport.f_name)
    Else
      Do Case
      Case Vartype(m.znh_now)="C"
        Do Case
        Case m.tmp_fend=="HEX"
          znh_now=ENCODE_SYMBOLS(m.znh_now)
        Case m.tmp_fusr=="IMG" And m.tmp_fend=="RM1"
          znh_now="{\pict\brdrs"+Substr(m.znh_now,7)
        Case m.tmp_fusr=="IMG" And m.tmp_fend=="RM2"
          znh_now="{\pict\brdrsh"+Substr(m.znh_now,7)
        Case m.tmp_fusr=="IMG" And m.tmp_fend=="RM3"
          znh_now="{\pict\brdrdb"+Substr(m.znh_now,7)
        Case m.tmp_fusr=="IMG" And m.tmp_fend=="ML5"  && масштабирование (уменьшение) картинки на 50%
          znh_now="{\pict\picscalex50\picscaley50"+Substr(m.znh_now,7)
        Otherwise
          m.znh_now=Alltrim(m.znh_now)
        Endcase
      Case Vartype(m.znh_now)="N"
        Do Case
        Case (m.tmp_fend=="BLK" Or m.tmp_fend=="BLZ") And m.znh_now=0  && одна из ф-й BLANK ZERO
          znh_now=''
        Case m.tmp_fend=="RAZ" Or m.tmp_fend=="BLZ"
          znh_now=NUM_RAZDEL(m.znh_now)
        Case m.tmp_fend=="NUM"
          znh_now=Alltrim(Chrtran(Padl(m.znh_now,30),".",","))
        Otherwise
          m.znh_now=Padl(m.znh_now,30)
        Endcase
      Case Vartype(m.znh_now)="D"
        m.znh_now=Dtoc(m.znh_now)
      Case Vartype(m.znh_now)="T"
        m.znh_now=Ttoc(m.znh_now)
      Case Vartype(m.znh_now)="L"
        Do Case
        Case m.tmp_fend=="LRU"
          m.znh_now=Iif(m.znh_now,"ДА","НЕТ")
        Otherwise
          m.znh_now=Iif(m.znh_now,"TRUE","FALSE")
        Endcase
      Endcase
*--------------------------------------------------------------------------------------------
* Пользовательская внешняя функция
*--------------------------------------------------------------------------------------------
      If !Empty(m.tmp_fout)
        tmp_fout=Iif("ZNH_NOW"$m.tmp_fout Or "ZNH_VAL"$m.tmp_fout Or "ZNH_CON"$m.tmp_fout,m.tmp_fout,m.tmp_fout+"(m.znh_val)")  && добавляем параметр со значением переменной
        Try
          znh_now=Evaluate(m.tmp_fout)
          znh_now=Iif(Vartype(m.znh_now)#"C","",m.znh_now)  && проверка, чтобы там снаружи не накосячили с типом возврата
        Catch
          znh_now=m.tmp_fout  && в случае ошибки показываем виновника торжества в отчете
        Endtry
      Endif
*--------------------------------------------------------------------------------------------
* Кодировка
*--------------------------------------------------------------------------------------------
      Do Case
      Case !Empty(m.tmp_code)    && указана перекодировка поля
        znh_now=Strconv(Alltrim(m.znh_now),m.tmp_code)
      Case !Empty(m.reps_cod)    && тотальная перекодировка файла
        znh_now=Strconv(Alltrim(m.znh_now),m.reps_cod)
      Endcase
*--------------------------------------------------------------------------------------------
    Endif
    Select _rtfreport
    f_ret = Fwrite(m.f_out,Alltrim(m.znh_now)+beetw_text)  && пишем в вых. файл
    If m.f_ret<0
      rep_errs='Ошибка записи в выходной файл!'
      Return -1
    Endif
  Endcase
Endscan
Return 1
*############################################################################################
*############################################################################################
*############################################################################################
Function GET_TBLDATA  && получение курсора данных для таблицы
Lparameters t_anomer,t_keydata,t_keyalia
* t_anomer   - номер алиаса
* t_keydata  - ключевое значение для выборки данных из таблицы
* t_keyalia  - алиас с данными для получения значения ключа
*--------------------------------------------------------------------------------------------
Local i,tbl__ali,tbl__key,tbl__usl,tbl__ord,tbl__des,ali__now,rep_okey,tbl__utp
Private key_data
=Seek(m.t_anomer,"_rtftables","k1")
tbl__ali=Alltrim(_rtftables.ALINOW)
tbl__key=Alltrim(_rtftables.ALIKEY)
tbl__usl=Alltrim(_rtftables.ALIUSL)
tbl__ord=Alltrim(_rtftables.ALIORD)
tbl__utp=_rtftables.ALIUTP
tbl__des=_rtftables.ALIDES
ali__now=GET_REPALIAS("[TBL]")
tbl__ord=Iif(Empty(m.tbl__ord),"1",m.tbl__ord)
tbl__key=GET_FUNCONV(m.tbl__key)
tbl__usl=GET_FUNCONV(m.tbl__usl)
rep_okey=1
Try
  Do Case
  Case Empty(m.tbl__usl)
    tbl__usl=1
    key_data=1
  Case !Empty(m.tbl__key) And !Empty(m.t_keyalia)
    Select (m.t_keyalia)
    key_data=Evaluate(m.tbl__key)  && получаем ключевое значение в алиасе контейнера
  Case Vartype(m.t_keydata)#"L"
    key_data=m.t_keydata      && ключевое значение для выборки данных из таблицы берется из контейнера
  Case !Empty(m.tbl__usl)        && условие задано в шаблоне
    tbl__usl=Evaluate(m.tbl__usl)
    key_data=.T.
  Otherwise
    tbl__usl=1
    key_data=1
  Endcase
Catch
  rep_okey=0
  rep_errs='Неверно задано ключевое выражение при описании таблицы!'
Endtry
*--------------------------------------------------------------------------------------------
* Получение курсора данных таблицы
*--------------------------------------------------------------------------------------------
If m.tbl__utp=0  && выборка по равенству
  TEXT TO tempusl NOSHOW TEXTMERGE PRETEXT 7
      SELECT <<m.tbl__ord>> AS order_fld,* ;
      FROM <<m.tbl__ali>> ;
      WHERE ;
        (<<m.tbl__usl>>)=m.key_data ;
      ORDER BY 1 <<IIF(m.tbl__des=1,"DESC","")>> ;
      INTO CURSOR <<m.ali__now>> READWRITE
  ENDTEXT
Else      && выборка по списку
  TEXT TO tempusl NOSHOW TEXTMERGE PRETEXT 7
      SELECT <<m.tbl__ord>> AS order_fld,* ;
      FROM <<m.tbl__ali>> ;
      WHERE ;
        <<m.tbl__usl>> IN (<<m.key_data>>) ;
      ORDER BY 1 <<IIF(m.tbl__des=1,"DESC","")>> ;
      INTO CURSOR <<m.ali__now>> READWRITE
  ENDTEXT
Endif
If m.rep_okey=1
  Try
    =Execscript(m.tempusl)
  Catch
    rep_okey=0
    rep_errs='Неверно заданы ключ или условие при описании таблицы!'
  Endtry
Endif
Return m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
Function GET_GRPTITL  && получение курсора группы заданного уровня
Lparameters t_anomer,grp_level
Local rep_okey
Private grp__zapr,grp__func,grp__tbls,grp__alia
=Seek(m.t_anomer,"_rtftables","k1")
grp__func=Alltrim(Evaluate("_rtftables.GR"+Alltrim(Str(m.grp_level))+"NOW"))
grp__tbls=GET_REPALIAS(Iif(m.grp_level=1,"[TBL]","[GR"+Alltrim(Str(m.grp_level-1))+"]"))
grp__alia=GET_REPALIAS("[GZ"+Alltrim(Str(m.grp_level))+"]")
If Empty(m.grp__func) And m.grp_level>1
  Return 1
Endif
grp__func=Iif(Empty(m.grp__func),"1",m.grp__func)
*--------------------------------------------------------------------------------------------
* Получение курсора групп
*--------------------------------------------------------------------------------------------
TEXT TO grp__zapr NOSHOW TEXTMERGE PRETEXT 7
    SELECT DISTINCT ;
      <<m.grp__func>> AS grp_dat ;
    FROM <<m.grp__tbls>> ;
    INTO CURSOR <<m.grp__alia>> READWRITE
ENDTEXT
rep_okey=1
Try
  =Execscript(m.grp__zapr)
Catch
  rep_okey=0
  rep_errs='Неверно задано выражение группы '+Alltrim(Str(m.grp_level))+' при описании таблицы!'
Endtry
Return m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
Function GET_GRPDATA  && получение курсора группы заданного уровня
Lparameters t_anomer,grp_level,grp_keydt
Local rep_okey
Private grp__zapr,grp__func,grp__tbls,grp__alia,t_grpnow
=Seek(m.t_anomer,"_rtftables","k1")
grp__func=Alltrim(Evaluate("_rtftables.GR"+Alltrim(Str(m.grp_level))+"NOW"))
grp__tbls=GET_REPALIAS(Iif(m.grp_level=1,"[TBL]","[GR"+Alltrim(Str(m.grp_level-1))+"]"))  && сурс уровнем выше
grp__alia=GET_REPALIAS("[GR"+Alltrim(Str(m.grp_level))+"]")
If Empty(m.grp__func) And m.grp_level>1
  Return 1
Endif
grp__func=Iif(Empty(m.grp__func),"1",m.grp__func)
*--------------------------------------------------------------------------------------------
* Получение курсора групп
*--------------------------------------------------------------------------------------------
t_grpnow=m.grp_keydt
TEXT TO grp__zapr NOSHOW TEXTMERGE PRETEXT 7
    SELECT * ;
    FROM <<m.grp__tbls>> ;
    WHERE ;
      <<m.grp__func>>=m.t_grpnow ;
    INTO CURSOR <<m.grp__alia>> READWRITE
ENDTEXT
rep_okey=1
Try
  =Execscript(m.grp__zapr)
Catch
  rep_okey=0
  rep_errs='Неверно задано выражение группы '+Alltrim(Str(m.grp_level))+' при описании таблицы!'
Endtry
Return m.rep_okey
*############################################################################################
*############################################################################################
*############################################################################################
Function RUN_SHET  && отработка всех счетчиков
Lparameters sh_level,sh_metod
* sh_level - уровень вложенности
*  1-контейнер,
*  2-таблица,
*  3-группа 1 уровня,
*  4-группа 2 уровня,
*  5-группа 3 уровня,
*  6-группа 4 уровня,
*  7-группа 5 уровня,
*  8-группа 6 уровня,
*  9-строка
* sh_metod - 0 - инициализация, 1-выполнение
*--------------------------------------------------------------------------------------------
*   1 rep_con - сквозной номер контейнера с начала отчета
*   2 rep_tbl - сквозной номер таблицы с начала отчета
*   3 rep_gr1 - сквозной номер группы 1 уровня с начала отчета
*   4 rep_gr2 - сквозной номер группы 2 уровня с начала отчета
*   5 rep_gr3 - сквозной номер группы 3 уровня с начала отчета
*   6 rep_gr4 - сквозной номер группы 4 уровня с начала отчета
*   7 rep_gr5 - сквозной номер группы 5 уровня с начала отчета
*   8 rep_gr6 - сквозной номер группы 6 уровня с начала отчета
*   9 rep_str - сквозной номер строки с начала отчета
*--------------------------------------------------------------------------------------------
*  10 con_all - всего строк в контейнере
*  11 con_now - текущая строка контейнера
*  12 con_str - сквозной номер строки с начала контейнера
*  13 con_tbl - сквозной номер таблицы с начала контейнера
*  14 con_gr1 - сквозной номер группы 1 уровня с начала контейнера
*  15 con_gr2 - сквозной номер группы 2 уровня с начала контейнера
*  16 con_gr3 - сквозной номер группы 3 уровня с начала контейнера
*  17 con_gr4 - сквозной номер группы 4 уровня с начала контейнера
*  18 con_gr5 - сквозной номер группы 5 уровня с начала контейнера
*  19 con_gr6 - сквозной номер группы 6 уровня с начала контейнера
*--------------------------------------------------------------------------------------------
*  20 tbl_all - всего строк в таблице
*  21 tbl_now - текущая строка таблицы (Не использовать!)
*  22 tbl_str - сквозной номер строки с начала таблицы
*  23 tbl_gr1 - сквозной номер группы 1 уровня с начала таблицы
*  24 tbl_gr2 - сквозной номер группы 2 уровня с начала таблицы
*  25 tbl_gr3 - сквозной номер группы 3 уровня с начала таблицы
*  26 tbl_gr4 - сквозной номер группы 4 уровня с начала таблицы
*  27 tbl_gr5 - сквозной номер группы 5 уровня с начала таблицы
*  28 tbl_gr6 - сквозной номер группы 6 уровня с начала таблицы
*  29 tbl_kol - Всего групп 1 уровня у этой таблицы
*--------------------------------------------------------------------------------------------
*  30 gr1_all - всего строк в группе 1 уровня
*  31 gr1_now - текущая группа 1 уровня
*  32 gr1_str - сквозной номер строки с начала группы 1 уровня
*  33 gr1_gr2 - сквозной номер группы 2 уровня с начала групп 1 уровня
*  34 gr1_gr3 - сквозной номер группы 3 уровня с начала групп 1 уровня
*  35 gr1_gr4 - сквозной номер группы 4 уровня с начала групп 1 уровня
*  36 gr1_gr5 - сквозной номер группы 5 уровня с начала групп 1 уровня
*  37 gr1_gr6 - сквозной номер группы 6 уровня с начала групп 1 уровня
*  38 gr1_kol - Всего групп 2 уровня у группы 1 уровня
*  39 gr1_tek - номер строки текущей группы 1 уровня
*--------------------------------------------------------------------------------------------
*  40 gr2_all - всего строк в группе 2 уровня
*  41 gr2_now - текущая группа 2 уровня
*  42 gr2_str - сквозной номер строки с начала группы 2 уровня
*  43 gr2_gr3 - сквозной номер группы 3 уровня с начала групп 2 уровня
*  44 gr2_gr4 - сквозной номер группы 4 уровня с начала групп 2 уровня
*  45 gr2_gr5 - сквозной номер группы 5 уровня с начала групп 2 уровня
*  46 gr2_gr6 - сквозной номер группы 6 уровня с начала групп 2 уровня
*  47 gr2_kol - Всего групп 3 уровня у группы 2 уровня
*  48 gr2_tek - номер строки текущей группы 2 уровня
*--------------------------------------------------------------------------------------------
*  49 gr3_all - всего строк в группе 3 уровня
*  50 gr3_now - текущая группа 3 уровня
*  51 gr3_str - сквозной номер строки с начала группы 3 уровня
*  52 gr3_gr4 - сквозной номер группы 4 уровня с начала групп 3 уровня
*  53 gr3_gr5 - сквозной номер группы 5 уровня с начала групп 3 уровня
*  54 gr3_gr6 - сквозной номер группы 6 уровня с начала групп 3 уровня
*  55 gr3_kol - Всего групп 4 уровня у группы 3 уровня
*  56 gr3_tek - номер строки текущей группы 3 уровня
*--------------------------------------------------------------------------------------------
*  57 gr4_all - всего строк в группе 4 уровня
*  58 gr4_now - текущая группа 4 уровня
*  59 gr4_str - сквозной номер строки с начала группы 4 уровня
*  60 gr4_gr5 - сквозной номер группы 5 уровня с начала групп 4 уровня
*  61 gr4_gr6 - сквозной номер группы 6 уровня с начала групп 4 уровня
*  62 gr4_kol - Всего групп 5 уровня у группы 4 уровня
*  63 gr4_tek - номер строки текущей группы 4 уровня
*--------------------------------------------------------------------------------------------
*  64 gr5_all - всего строк в группе 5 уровня
*  65 gr5_now - текущая группа 5 уровня
*  66 gr5_str - сквозной номер строк с начала группы 5 уровня
*  67 gr5_gr6 - сквозной номер группы 6 уровня с начала групп 5 уровня
*  68 gr5_kol - Всего групп 6 уровня у группы 5 уровня
*  69 gr5_tek - номер строки текущей группы 5 уровня
*--------------------------------------------------------------------------------------------
*  70 gr6_all - всего строк в группе 6 уровня
*  71 gr6_now - текущая группа 6 уровня
*  72 gr6_tek - номер строки текущей группы 6 уровня
*--------------------------------------------------------------------------------------------
Local i
If m.sh_metod=0
*--------------------------------------------------------------------------------------------
* Инициализация счетчиков контейнера, таблицы
*--------------------------------------------------------------------------------------------
  Do Case
  Case m.sh_level=2    && таблица
    rep_shet(20)=Reccount(GET_REPALIAS("[TBL]"))
  Case m.sh_level=1    && контейнер
    rep_shet(10)=Reccount(GET_REPALIAS("[CON]"))
  Endcase
*--------------------------------------------------------------------------------------------
* Сброс подчиненных счетчиков
*--------------------------------------------------------------------------------------------
  For i=1 To 72
    Do Case
    Case m.sh_level<=8 And Inlist(m.i,71,72)            && группа 6 уровня
      rep_shet(m.i)=0
    Case m.sh_level<=7 And Inlist(m.i,65,66,67,69)          && группа 5 уровня
      rep_shet(m.i)=0
    Case m.sh_level<=6 And Inlist(m.i,58,59,60,61,63)        && группа 4 уровня
      rep_shet(m.i)=0
    Case m.sh_level<=5 And Inlist(m.i,50,51,52,53,54,56)      && группа 3 уровня
      rep_shet(m.i)=0
    Case m.sh_level<=4 And Inlist(m.i,41,42,43,44,45,46,48)      && группа 2 уровня
      rep_shet(m.i)=0
    Case m.sh_level<=3 And Inlist(m.i,31,32,33,34,35,36,37,39)    && группа 1 уровня
      rep_shet(m.i)=0
    Case m.sh_level<=2 And Inlist(m.i,21,22,23,24,25,26,27,28)    && таблица
      rep_shet(m.i)=0
    Case m.sh_level<=1 And Inlist(m.i,11,12,13,14,15,16,17,18,19)  && контейнер
      rep_shet(m.i)=0
    Endcase
  Endfor
Else
*--------------------------------------------------------------------------------------------
* Отработка счетчиков объектов
*--------------------------------------------------------------------------------------------
  If Between(m.sh_level,1,8)
    For i=1 To 72
      Do Case
      Case m.sh_level=8 And Inlist(m.i,8,19,28,37,46,54,61,67)    && группа 6 уровня
        rep_shet(m.i)=rep_shet(m.i)+1
      Case m.sh_level=7 And Inlist(m.i,7,18,27,36,45,53,60)      && группа 5 уровня
        rep_shet(m.i)=rep_shet(m.i)+1
      Case m.sh_level=6 And Inlist(m.i,6,17,26,35,44,52)        && группа 4 уровня
        rep_shet(m.i)=rep_shet(m.i)+1
      Case m.sh_level=5 And Inlist(m.i,5,16,25,34,43)           && группа 3 уровня
        rep_shet(m.i)=rep_shet(m.i)+1
      Case m.sh_level=4 And Inlist(m.i,4,15,24,33)          && группа 2 уровня
        rep_shet(m.i)=rep_shet(m.i)+1
      Case m.sh_level=3 And Inlist(m.i,3,14,23)            && группа 1 уровня
        rep_shet(m.i)=rep_shet(m.i)+1
      Case m.sh_level=2 And Inlist(m.i,2,13)              && таблица
        rep_shet(m.i)=rep_shet(m.i)+1
      Case m.sh_level=1 And Inlist(m.i,1)                && контейнер
        rep_shet(m.i)=rep_shet(m.i)+1
      Endcase
    Endfor
  Endif
*--------------------------------------------------------------------------------------------
* Отработка счетчиков текущих строк объектов по уровню
*--------------------------------------------------------------------------------------------
  Do Case
  Case m.sh_level=9             && DETAIL
    rep_shet( 9)=rep_shet(9)+1
    rep_shet(12)=rep_shet(12)+Iif(rep_shet(11)#0,1,0)  && CON

    rep_shet(22)=rep_shet(22)+Iif(rep_shet(20)#0,1,0)  && TBL

    rep_shet(32)=rep_shet(32)+Iif(rep_shet(31)#0,1,0)  && GR1
    rep_shet(39)=rep_shet(39)+Iif(rep_shet(31)#0,1,0)  && GR1

    rep_shet(42)=rep_shet(42)+Iif(rep_shet(41)#0,1,0)  && GR2
    rep_shet(48)=rep_shet(48)+Iif(rep_shet(41)#0,1,0)  && GR2

    rep_shet(51)=rep_shet(51)+Iif(rep_shet(50)#0,1,0)  && GR3
    rep_shet(56)=rep_shet(56)+Iif(rep_shet(50)#0,1,0)  && GR3

    rep_shet(59)=rep_shet(59)+Iif(rep_shet(58)#0,1,0)  && GR4
    rep_shet(63)=rep_shet(63)+Iif(rep_shet(58)#0,1,0)  && GR4

    rep_shet(66)=rep_shet(66)+Iif(rep_shet(65)#0,1,0)  && GR5
    rep_shet(69)=rep_shet(69)+Iif(rep_shet(65)#0,1,0)  && GR5

    rep_shet(72)=rep_shet(72)+Iif(rep_shet(71)#0,1,0)  && GR6
  Case m.sh_level=8             && группа 6 уровня
    rep_shet(71)=rep_shet(71)+1
    rep_shet(72)=0
    rep_shet(70)=Reccount(GET_REPALIAS("[GR6]"))
    rep_shet(68)=Reccount(GET_REPALIAS("[GZ6]"))
  Case m.sh_level=7             && группа 5 уровня
    rep_shet(65)=rep_shet(65)+1
    rep_shet(69)=0
    rep_shet(64)=Reccount(GET_REPALIAS("[GR5]"))
    rep_shet(62)=Reccount(GET_REPALIAS("[GZ5]"))
  Case m.sh_level=6             && группа 4 уровня
    rep_shet(58)=rep_shet(58)+1
    rep_shet(63)=0
    rep_shet(57)=Reccount(GET_REPALIAS("[GR4]"))
    rep_shet(55)=Reccount(GET_REPALIAS("[GZ4]"))
  Case m.sh_level=5             && группа 3 уровня
    rep_shet(50)=rep_shet(50)+1
    rep_shet(56)=0
    rep_shet(49)=Reccount(GET_REPALIAS("[GR3]"))
    rep_shet(47)=Reccount(GET_REPALIAS("[GZ3]"))
  Case m.sh_level=4             && группа 2 уровня
    rep_shet(41)=rep_shet(41)+1
    rep_shet(48)=0
    rep_shet(40)=Reccount(GET_REPALIAS("[GR2]"))
    rep_shet(38)=Reccount(GET_REPALIAS("[GZ2]"))
  Case m.sh_level=3             && группа 1 уровня
    rep_shet(31)=rep_shet(31)+1
    rep_shet(39)=0
    rep_shet(30)=Reccount(GET_REPALIAS("[GR1]"))
    rep_shet(29)=Reccount(GET_REPALIAS("[GZ1]"))
  Case m.sh_level=2             && таблица
    rep_shet(21)=rep_shet(21)+1
  Case m.sh_level=1             && контейнер
    rep_shet(11)=rep_shet(11)+1
  Endcase
Endif
*--------------------------------------------------------------------------------------------
* Формирование переменных
*--------------------------------------------------------------------------------------------
rep_con=rep_shet( 1)
rep_tbl=rep_shet( 2)
rep_gr1=rep_shet( 3)
rep_gr2=rep_shet( 4)
rep_gr3=rep_shet( 5)
rep_gr4=rep_shet( 6)
rep_gr5=rep_shet( 7)
rep_gr6=rep_shet( 8)
rep_str=rep_shet( 9)
con_all=rep_shet(10)
con_now=rep_shet(11)
con_str=rep_shet(12)
con_tbl=rep_shet(13)
con_gr1=rep_shet(14)
con_gr2=rep_shet(15)
con_gr3=rep_shet(16)
con_gr4=rep_shet(17)
con_gr5=rep_shet(18)
con_gr6=rep_shet(19)
tbl_all=rep_shet(20)
tbl_now=rep_shet(21)  && (Не использовать!)
tbl_str=rep_shet(22)
tbl_gr1=rep_shet(23)
tbl_gr2=rep_shet(24)
tbl_gr3=rep_shet(25)
tbl_gr4=rep_shet(26)
tbl_gr5=rep_shet(27)
tbl_gr6=rep_shet(28)
tbl_kol=rep_shet(29)
gr1_all=rep_shet(30)
gr1_now=rep_shet(31)
gr1_str=rep_shet(32)
gr1_gr2=rep_shet(33)
gr1_gr3=rep_shet(34)
gr1_gr4=rep_shet(35)
gr1_gr5=rep_shet(36)
gr1_gr6=rep_shet(37)
gr1_kol=rep_shet(38)
gr1_tek=rep_shet(39)
gr2_all=rep_shet(40)
gr2_now=rep_shet(41)
gr2_str=rep_shet(42)
gr2_gr3=rep_shet(43)
gr2_gr4=rep_shet(44)
gr2_gr5=rep_shet(45)
gr2_gr6=rep_shet(46)
gr2_kol=rep_shet(47)
gr2_tek=rep_shet(48)
gr3_all=rep_shet(49)
gr3_now=rep_shet(50)
gr3_str=rep_shet(51)
gr3_gr4=rep_shet(52)
gr3_gr5=rep_shet(53)
gr3_gr6=rep_shet(54)
gr3_kol=rep_shet(55)
gr3_tek=rep_shet(56)
gr4_all=rep_shet(57)
gr4_now=rep_shet(58)
gr4_str=rep_shet(59)
gr4_gr5=rep_shet(60)
gr4_gr6=rep_shet(61)
gr4_kol=rep_shet(62)
gr4_tek=rep_shet(63)
gr5_all=rep_shet(64)
gr5_now=rep_shet(65)
gr5_str=rep_shet(66)
gr5_gr6=rep_shet(67)
gr5_kol=rep_shet(68)
gr5_tek=rep_shet(69)
gr6_all=rep_shet(70)
gr6_now=rep_shet(71)
gr6_tek=rep_shet(72)
Return
*############################################################################################
*############################################################################################
*############################################################################################
Function SHOW_PROC  && вывод % выполнения формирования отчета
Local proc_new
proc_new=Round((m.proc_now/m.proc_all)*100,0)
If m.proc_new#m.proc_kol  && кол-во %
  proc_kol=m.proc_new
  Wait Window Iif("[HIDE]"$Upper(m.rep_config),"","Идет формирование отчета: "+Alltrim(Str(m.proc_kol))+" %"+Chr(13)+"Раздел "+Alltrim(Str(m.proc_rzd))+" из "+Alltrim(Str(m.proc_glv))) Nowait Noclear
Endif
Return
*############################################################################################
*############################################################################################
*############################################################################################
Function GET_FUNCONV  && Конвертация подстановок поля
Lparameters get_data
get_data=Strtran(m.get_data,"[CON]",GET_REPALIAS("[CON]"),-1,-1,1)
get_data=Strtran(m.get_data,"[TBL]",GET_REPALIAS("[TBL]"),-1,-1,1)
get_data=Strtran(m.get_data,"[GR1]",GET_REPALIAS("[GR1]"),-1,-1,1)
get_data=Strtran(m.get_data,"[GR2]",GET_REPALIAS("[GR2]"),-1,-1,1)
get_data=Strtran(m.get_data,"[GR3]",GET_REPALIAS("[GR3]"),-1,-1,1)
get_data=Strtran(m.get_data,"[GR4]",GET_REPALIAS("[GR4]"),-1,-1,1)
get_data=Strtran(m.get_data,"[GR5]",GET_REPALIAS("[GR5]"),-1,-1,1)
get_data=Strtran(m.get_data,"[GR6]",GET_REPALIAS("[GR6]"),-1,-1,1)
Return Alltrim(m.get_data)
*############################################################################################
*############################################################################################
*############################################################################################
Function GET_REPALIAS  && Получение алиасов курсоров отчета
Lparameters get_data
Local ret_data
ret_data=''
Do Case
Case m.get_data=="[CON]"
  ret_data="_dat_con"
Case m.get_data=="[TBL]"
  ret_data="_dat_tbl"
Case m.get_data=="[GR1]"
  ret_data="_dat_gr1"
Case m.get_data=="[GZ1]"
  ret_data="_zag_gr1"
Case m.get_data=="[GR2]"
  ret_data="_dat_gr2"
Case m.get_data=="[GZ2]"
  ret_data="_zag_gr2"
Case m.get_data=="[GR3]"
  ret_data="_dat_gr3"
Case m.get_data=="[GZ3]"
  ret_data="_zag_gr3"
Case m.get_data=="[GR4]"
  ret_data="_dat_gr4"
Case m.get_data=="[GZ4]"
  ret_data="_zag_gr4"
Case m.get_data=="[GR5]"
  ret_data="_dat_gr5"
Case m.get_data=="[GZ5]"
  ret_data="_zag_gr5"
Case m.get_data=="[GR6]"
  ret_data="_dat_gr6"
Case m.get_data=="[GZ6]"
  ret_data="_zag_gr6"
Case m.get_data=="[REP]"
  ret_data="_rtf_rep"
Case m.get_data=="[RZD]"
  ret_data="_rtf_con"
Endcase
Return m.ret_data
*############################################################################################
*############################################################################################
*############################################################################################
Function READ_RTF  && загрузка шаблона как структуры
Parameters f_shabl
Private f_body,l_body
*--------------------------------------------------------------------------------------------
* Открытие шаблона и начало работы
*--------------------------------------------------------------------------------------------
If File(m.f_shabl)
  f_body=Filetostr(m.f_shabl)
  l_body=Len(m.f_body)
  If !Empty(m.l_body) && открылся
    Do Case
    Case !Empty(Juststem(m.f_othet))  && задан путь и имя файла отчета
      f_othet=m.f_othet
    Case !Empty(Justpath(m.f_othet))  && задан только путь
      f_othet=Addbs(Justpath(m.f_othet))+Juststem(m.f_shabl)+'.rtf'
    Otherwise
      f_othet=Addbs(Justpath(m.f_shabl))+Juststem(m.f_shabl)+'_out.rtf'  && берем файл шаблона и кладем рядом результат с добавкой _out в имени файла
    Endcase
  Else
    rep_errs='Не удалось открыть файл шаблона!'
    Return -1
  Endif
Else
  rep_errs='Не найден файл шаблона!'
  Return -1
Endif
*--------------------------------------------------------------------------------------------
* создаем таблицу структуры отчета
*--------------------------------------------------------------------------------------------
Create Cursor _rtftables ( ;
  tnomer N(10), ;    && ID алиаса
ALINOW C(20), ;    && алиас
ALIADD N(1), ;    && 0 - не добавлять пустые (по умолчанию), 1 - добавлять всегда
ALIORD C(250), ;  && выражение сортировки
ALIDES N(1), ;    && 1 - сортировка DESCENDING
ALIKEY C(250), ;  && выражение ключа контейнера, в который входит таблица
ALIUSL C(250), ;  && выражение условия
ALIUTP N(1), ;    && Тип условия 0-=,1-$
GR1NOW C(250), ;  && выражение группировки 1 уровня
GR2NOW C(250), ;  && выражение группировки 2 уровня
GR3NOW C(250), ;  && выражение группировки 3 уровня
GR4NOW C(250), ;  && выражение группировки 4 уровня
GR5NOW C(250), ;  && выражение группировки 5 уровня
GR6NOW C(250))    && выражение группировки 6 уровня
Index On tnomer Tag K1 Additive
Create Cursor _rtfreport ( ;
  rid N(10), ;    && ID строки
rnomer N(10), ;    && ID раздела
rztype N(2), ;    && Тип раздела
obtype N(2), ;    && Тип объекта
obkolv N(10), ;    && Порядковый номер объекта в разделе
tnomer N(10), ;    && ID алиаса
rodrid N(10), ;    && ID строки родительского объекта
caseid N(10), ;    && ID строки родительского CASE
grnext N(10), ;    && ID раздела подгруппы для этой группы или таблицы
grpend N(10), ;    && ID раздела подвала для этой группы или таблицы
func_txt C(3), ;  && функция суммирования
func_usr C(3), ;  && функция преобразования
func_end C(3), ;  && функция окончательного форматирования
func_out C(250), ;  && внешняя функция окончательного форматирования (выполняется после всего)
func_ali C(20), ;  && алиас выполнения функции суммирования или вычисления значения
code_txt N(2), ;  && Перекодировка значения
f_name C(250), ;  && распознанный текст в скобках []
objusl C(250), ;  && выражение условия добавления объекта
beetw_text M)    && тело файла
Index On rid Tag K1 Additive
Index On Str(tnomer,10)+Str(obtype,2) Tag K3 Additive
Index On rnomer Tag K5 Additive
Set Order To K1
Create Cursor _rtfvables ( ;
  VID N(10), ;    && ID строки
func_txt C(3), ;  && функция суммирования
func_usr C(3), ;  && функция преобразования
func_end C(3), ;  && функция окончательного форматирования
func_out C(250), ;  && внешняя функция окончательного форматирования (выполняется после всего)
func_ali C(20), ;  && алиас выполнения функции суммирования или вычисления значения
code_txt N(2), ;  && Перекодировка значения
f_name C(250))    && распознанный текст в скобках []
Index On VID Tag K1 Additive
*--------------------------------------------------------------------------------------------
* Заполняем структуру
*--------------------------------------------------------------------------------------------
Dimension tag_mass(100)  && массив стек открытых тегов
Dimension ali_mass(100)  && массив стек алиасов
Local fld_kus
Private tag_kolv,ali_kolv,rzd_nomer,rzd_type,rzd_oldt,rzd_kolvo,obj_type,obj_count,obj_body,tbl_count,tmp_body,ret_block
tag_kolv=0  && кол-во управляющих тегов в массиве tag_mass
ali_kolv=0  && кол-во алиасов в массиве ali_mass
rzd_nomer=0  && текущий № раздела
rzd_type=8  && текущий тип = постоянная часть отчета
rzd_oldt=8  && предыдущий тип для счетчика
rzd_count=0  && кол-во разделов
rzd_kolvo=0  && кол-во объектов в текущем разделе
obj_type=0  && тип объекта (1- поле или функция)
obj_count=0  && кол-во объектов всего (ID)
obj_body=''  && поле или функция
tbl_count=0  && кол-во таблиц всего (текущий ID для добавления)
tmp_body=''  && часть тела файла для записи
ret_block=1  && признак записи 1-прямо в файл, 0 - в tmp_body
Do While !Empty(m.f_body)
*--------------------------------------------------------------------------------------------
* Считываем кусок файла
*--------------------------------------------------------------------------------------------
  Do Case
  Case Left(m.f_body,1)="["              && если слева "[" берем только 1 символ
    fld_kus = "["
  Case At("[",m.f_body)>0
    fld_kus = Left(m.f_body,At("[",m.f_body)-1)    && если есть "[" берем все до символа "["
  Otherwise
    fld_kus =m.f_body
  Endcase
  f_body=Substr(m.f_body,Len(m.fld_kus)+1)      && удаляем ту часть, которую обработали
*--------------------------------------------------------------------------------------------
* Обрабатываем кусок
*--------------------------------------------------------------------------------------------
  If m.fld_kus='['
    If m.ret_block=1
      =ADD_STRU()  && добавление строки в структурный файл
    Endif
    ret_block=REBLD_BLOK()
    Do Case
    Case m.ret_block=0  && продолжить сканирование в файл
      Replace beetw_text With _rtfreport.beetw_text+"[" In _rtfreport
    Case m.ret_block=-1
      Return -1
    Otherwise
      f_body=Substr(m.f_body,m.ret_block+1)  && удаляем ту часть, которую обработали в REBLD_BLOK()
      ret_block=1                && предыдущий блок распознан - сканирование в m.tmp_body
    Endcase
  Else
    If m.ret_block=0        && продолжить сканирование в файл
      Replace beetw_text With _rtfreport.beetw_text+m.fld_kus In _rtfreport
    Else
      tmp_body=m.tmp_body+m.fld_kus
    Endif
  Endif
Enddo
=ADD_STRU()  && добавление строки в структурный файл
*--------------------------------------------------------------------------------------------
* Проверяем кодировку
*--------------------------------------------------------------------------------------------
=FONT_RECODE()  && Функция перекодировки шрифтов
*--------------------------------------------------------------------------------------------
* Проверки алиасов
*--------------------------------------------------------------------------------------------
Select _rtftables
Scan
  If !Used(Alltrim(ALINOW))
    rep_errs='Не найден алиас '+Alltrim(ALINOW)+'!'
    Return -1
  Endif
Endscan
*--------------------------------------------------------------------------------------------
* Выковыриваем функции, причесываем поля
*--------------------------------------------------------------------------------------------
Local i,tmp_name,tmp_alia,tmp_func,tmp_rid,tmp_text,tmp_fusr,tmp_fend,tmp_rvar,tmp_fout,tmp_code
Select _rtfreport
Scan For obtype=9
  tmp_name=Alltrim(f_name)
  tmp_alia=''
  tmp_func=''
  tmp_fusr=''
  tmp_fend=''
  tmp_fout=''
  tmp_rvar=0
  tmp_code=0
  For i=1 To 10
    tmp_text=Upper(Getwordnum(m.tmp_name,1,":"))
    Do Case
    Case Left(m.tmp_text,6)=="REPVAR"      && объявление подстановки
      If _rtfreport.rztype#1  && если не заголовок, подвал отчета
        rep_errs='Объявлена подстановка внутри контейнера или таблицы!'
        Return -1
      Endif
      tmp_rvar=Val(Substr(m.tmp_text,7))
      tmp_name=Alltrim(Substr(m.tmp_name,At(":",m.tmp_name)+1))  && отсекаем ф-ю
    Case Len(m.tmp_text)=3 And Inlist(m.tmp_text,"SUM","MAX","MIN","CNT","AVG")      && функции подсчета
      tmp_func=m.tmp_text
      tmp_name=Alltrim(Substr(m.tmp_name,At(":",m.tmp_name)+1))  && отсекаем ф-ю
    Case Len(m.tmp_text)=3 And Inlist(m.tmp_text,"DAT","TDT","PN1","PN2","PN3","PN4","KOL","RUB","INT","DEC","RD0","RD1","RD2","RD3","IMG","PAR")    && функции преобразования
      tmp_fusr=m.tmp_text
      tmp_name=Alltrim(Substr(m.tmp_name,At(":",m.tmp_name)+1))  && отсекаем ф-ю
    Case Len(m.tmp_text)=3 And Inlist(m.tmp_text,"CON","TBL","GR1","GR2","GR3","GR4","GR5","GR6")    && ссылка на алиас
      tmp_alia=GET_REPALIAS("["+m.tmp_text+"]")
      tmp_name=Alltrim(Substr(m.tmp_name,At(":",m.tmp_name)+1))  && отсекаем ф-ю
    Case Len(m.tmp_text)=3 And Inlist(m.tmp_text,"HEX","RAZ","RM1","RM2","RM3","LRU","BLZ","BLK","ML5","NUM")    && функции окончательного форматирования
      tmp_fend=m.tmp_text
      tmp_name=Alltrim(Substr(m.tmp_name,At(":",m.tmp_name)+1))  && отсекаем ф-ю
    Case Left(m.tmp_text,4)=="FUN="    && пользовательская функция отображения данных
      tmp_fout=Substr(m.tmp_text,5)
      tmp_name=Alltrim(Substr(m.tmp_name,At(":",m.tmp_name)+1))  && отсекаем ф-ю
    Case Left(m.tmp_text,4)=="COD="  && перекодировка, заданная для этого поля
      tmp_code=Val(Substr(m.tmp_text,5))
      tmp_name=Alltrim(Substr(m.tmp_name,At(":",m.tmp_name)+1))  && отсекаем ф-ю
    Otherwise
      Exit
    Endcase
  Endfor
  tmp_name=GET_FUNCONV(m.tmp_name)
  If m.tmp_rvar=0    && переменная
    Replace func_txt With m.tmp_func,func_usr With m.tmp_fusr,func_ali With m.tmp_alia,f_name With m.tmp_name,func_end With m.tmp_fend, func_out With m.tmp_fout, code_txt With tmp_code
  Else        && подстановка
    If Seek(m.tmp_rvar,"_rtfvables","k1")
      rep_errs='Объявлены две подстановки с одинаковыми ID='+Alltrim(Str(m.tmp_rvar))+'!'
      Return -1
    Endif
    Replace f_name With "''"  && переменная подстановка в тексте документа будет схлопнута
    Insert Into _rtfvables (VID,func_txt,func_usr,func_ali,f_name,func_end,func_out,code_txt) ;
      VALUES (m.tmp_rvar,m.tmp_func,m.tmp_fusr,m.tmp_alia,m.tmp_name,m.tmp_fend,m.tmp_fout,m.tmp_code)
  Endif
Endscan
*--------------------------------------------------------------------------------------------
* Заполняем поле ID родительского объекта (вложенность алиасов)
*--------------------------------------------------------------------------------------------
tmp_rid=0
Select _rtfreport
Scan
  Do Case
  Case obtype=10
    tmp_rid=rid
  Case obtype=11
    tmp_rid=0
  Otherwise
    If !Empty(m.tmp_rid)
      Replace rodrid With m.tmp_rid
    Endif
  Endcase
Endscan
*--------------------------------------------------------------------------------------------
* Проверяем, чтобы не было одинаковых алиасов у контейнера и вложенной таблицы
*--------------------------------------------------------------------------------------------
Select _rtfreport
Scan For obtype=2 And !Empty(rodrid)  && таблицы
  tmp_alia=tnomer
  tmp_rid=rid
  =Seek(rodrid,"_rtfreport","k1")
  If m.tmp_alia=tnomer
    rep_errs='Одинаковые алиасы у контейнера и вложенной таблицы!'
    Return -1
  Endif
  =Seek(m.tmp_rid,"_rtfreport","k1")
Endscan
*--------------------------------------------------------------------------------------------
* Проверяем, чтобы каждая таблица имела DETAIL
*--------------------------------------------------------------------------------------------
tmp_alia=0
Select _rtfreport
Scan For Inlist(obtype,2,4)    && таблицы и их DETAIL
  tmp_alia=m.tmp_alia+Iif(obtype=2,1,-1)
Endscan
If m.tmp_alia#0
  rep_errs='Проверьте наличие тега DETAIL у всех таблиц!'
  Return -1
Endif
*--------------------------------------------------------------------------------------------
* Проверяем, чтобы не было пересечений CASE с другими тегами и проставляем родительский CASEID
*--------------------------------------------------------------------------------------------
tmp_rid=0
Select _rtfreport
Scan
  Do Case
  Case Inlist(obtype,13,14)
    tmp_rid=rid
  Case Inlist(obtype,15)
    tmp_rid=0
  Endcase
  If m.tmp_rid#0
    If Inlist(obtype,1,2,3,4,5,6,7,8,10,11)  && пересечение с другими тегами
      rep_errs='Проверьте тег CASE/ENDCASE он пересекается с другими тегами!'
      Return -1
    Endif
    Replace caseid With m.tmp_rid
  Endif
Endscan
*--------------------------------------------------------------------------------------------
* Заполняем поля GRNEXT и GRPEND
*--------------------------------------------------------------------------------------------
Dimension grp_rids(6)  && RID хвостов
grp_rids=0
grp_kols=0        && кол-во незанятых хвостов
grp_next=0        && следующая группа
grp_detl=0        && RID detail
Select _rtfreport
Set Order To K1 Descending
Scan For Inlist(obtype,2,5,3,6,7)    && группы и их хвосты, таблицы и их ENDDETAILN и ENDALIAS
  Do Case
  Case Inlist(obtype,5,6)  && хвост, ENDDETAIL
    grp_kols=m.grp_kols+1
    Dimension grp_rids(m.grp_kols)  && RID хвостов
    grp_rids(m.grp_kols)=rnomer
  Case Inlist(obtype,2,3)  && таблица, группа
    If !Empty(m.grp_next)
      Replace grnext With m.grp_next
    Endif
    Do Case
    Case obtype=2 And m.grp_kols>0      && хвостов может на всех не хватить!
      Replace grpend With grp_rids(m.grp_kols)
      grp_kols=0
      grp_next=0
    Case obtype=3
      If m.grp_kols>1      && хвостов может на всех не хватить!
        Replace grpend With grp_rids(m.grp_kols)
        grp_kols=m.grp_kols-1
      Endif
      grp_next=rnomer
    Endcase
  Endcase
Endscan
Set Order To K1
*--------------------------------------------------------------------------------------------
* Заполняем поле OBJUSL
*--------------------------------------------------------------------------------------------
Select _rtfreport
Scan For Inlist(obtype,12)    && ENDPAGE
  tmp_fld=Upper(f_name)  && убираем регистрозависимость из условия
  For i=1 To Getwordcount(m.tmp_fld,"|")
    tbl_txt=Alltrim(Getwordnum(m.tmp_fld,m.i,"|"))
    tbl_dat=Alltrim(Substr(m.tbl_txt,At("=",m.tbl_txt)+1))
    If Upper(Left(Chrtran(m.tbl_txt," ",""),4))=="USL="
      Replace objusl With m.tbl_dat
      Loop
    Endif
  Endfor
Endscan
*--------------------------------------------------------------------------------------------
* Убираем лишние ENTER, оставшиеся после разбора строк со структурой
*--------------------------------------------------------------------------------------------
Select _rtfreport
Scan For Inlist(obtype,1,2,3,4,5,6,7,8,10,11,12,13,14,15)    && УПРАВЛЯЮЩИЕ ТЕГИ
  Do Case
  Case Asc(Left(beetw_text,1))=13 And Asc(Substr(beetw_text,2,1))=10
    Replace beetw_text With Substr(beetw_text,3)
  Case Asc(Left(beetw_text,1))=13
    Replace beetw_text With Substr(beetw_text,2)
  Endcase
Endscan
*--------------------------------------------------------------------------------------------
* Проверяем, не нужно ли изменить тип значения для ячеек, имеющих признач числа
*--------------------------------------------------------------------------------------------
If "[EXCEL]"$Upper(m.rep_config)
  Select Recno() As izmnow From _rtfreport Where "NUM"$func_end Into Cursor _tmpreport Readwrite
  Replace All izmnow With izmnow-1
  Select _tmpreport
  Scan
    Go _tmpreport.izmnow In _rtfreport
    If 'Type="String"'$_rtfreport.beetw_text
      Replace beetw_text With Strtran(_rtfreport.beetw_text,'Type="String"','Type="Number"',Occurs('Type="String"',_rtfreport.beetw_text)) In _rtfreport
    Endif
  Endscan
  Use In _tmpreport
Endif
*--------------------------------------------------------------------------------------------
* Тотальная перекодировка файла
*--------------------------------------------------------------------------------------------
If m.reps_cod#0
  Select _rtfreport
  Scan
    Replace beetw_text With Strconv(beetw_text,m.reps_cod)
  Endscan
Endif
Return 1


*############################################################################################
*############################################################################################
*############################################################################################
Function ADD_STRU  && добавление строки в структурный файл
obj_count=m.obj_count+1
tbl_alias=Iif(m.ali_kolv=0,0,ali_mass(m.ali_kolv))
If m.rzd_type#m.rzd_oldt
  rzd_kolvo=1
  rzd_oldt=m.rzd_type
  rzd_count=m.rzd_count+1
Else
  rzd_kolvo=m.rzd_kolvo+1
Endif
If m.obj_type#9  && если не переменная - убираем перевод строки
  tmp_body=Strtran(m.tmp_body,'\par ','',1,1,1)
Endif
Insert Into _rtfreport(rid,rnomer,rztype,obtype,f_name,beetw_text,tnomer,obkolv) ;
  VALUES(m.obj_count,m.rzd_count,m.rzd_type,m.obj_type,m.obj_body,m.tmp_body,m.tbl_alias,m.rzd_kolvo)
tmp_body=''
Return
*############################################################################################
*############################################################################################
*############################################################################################
Function FONT_RECODE  && Функция перекодировки шрифтов
Local i,i1,j1,text_new
Select _rtfreport
=Seek(1,"_rtfreport","k1")
m.text_new=beetw_text
For i=1 To 3
  i1 = At('fcharset', m.text_new,m.i)
  If m.i1>0  && найдены установки шрифтов
    i2 = At('\', Substr(m.text_new,m.i1))
    text_new=Substr(m.text_new,1,m.i1-1)+"fcharset204"+Substr(m.text_new,m.i1+m.i2-1)
  Endif
Endfor
Replace beetw_text With m.text_new
Return
*############################################################################################
*############################################################################################
*############################################################################################
Function REBLD_BLOK  && Функция обработки поля
Local i,fld_txt,fld_teg,fld_txt1,fld_kus,kolskb,readpz,len_block
Local tbl__alia,tbl__key,tbl__usl,tbl__utp,tbl__ord,tbl__add,tbl__des
fld_txt=''
fld_kus=''
*--------------------------------------------------------------------------------------------
* считывает все, что находится до следующей закрывающей скобки с учетом того, что могут быть вложенные скобки []
*--------------------------------------------------------------------------------------------
i=0
Do While .T.
  i=m.i+1
  fld_txt=Left(m.f_body,At("]",m.f_body,m.i))        && берем все до символа "]" включительно
  Do Case
  Case !Empty(m.fld_txt)
    If Occurs("]",m.fld_txt)-Occurs("[",m.fld_txt)=1  && закрывающих квадратных скобок на 1 больше
      Exit
    Endif
  Otherwise
    fld_txt=m.f_body                  && берем все - не нашли закрываюшую квадратную скобку
    Exit
  Endcase
Enddo
len_block=Len(m.fld_txt)                  && длина блока для удаления обработанной строки
fld_txt=Left(m.fld_txt,Len(m.fld_txt)-1)          && убираем закрывающую квадратную скобку
*--------------------------------------------------------------------------------------------
* избавляемся от RTF в поле, если он там есть
*--------------------------------------------------------------------------------------------
Local cntrus,lenfld,rpos,rkod,rsymb
fld_txt = Chrtran(m.fld_txt, Chr(13)+Chr(10),'')
If At('}',m.fld_txt)>0 Or At('{',m.fld_txt)>0 Or At('\',m.fld_txt)>0
  cntrus=Occurs("\'", m.fld_txt)  && кол-во русских символов в поле в формате RTF (hex-коды)
  If m.cntrus>0  && если есть такие, то переводим их в буквы
    For i = 1 To m.cntrus  && идем по всем русским кодам
      rpos = At("\'", m.fld_txt)
      rkod = Substr(m.fld_txt, m.rpos + 2,2)  && находим код
      rsymb = Evaluate('CHR(0x' + m.rkod + ')')
      fld_txt = Stuff(m.fld_txt, m.rpos, 4, m.rsymb)
    Endfor
  Endif
  fld_txt = Strtran(m.fld_txt, '\rquote ',"'",-1,-1,1)  && заменяем RTF одиночной кавычки на символ
  fld_txt1 = m.fld_txt
  fld_txt=''
  lenfld = Len(m.fld_txt1)
  For i=1 To m.lenfld
    fld_kus = Substr(m.fld_txt1,m.i,1)
    If Inlist(m.fld_kus,'}','{','\')  && начало куска RTF
      Do While m.i<=m.lenfld
        fld_kus = Substr(m.fld_txt1,m.i,1)
        If Inlist(m.fld_kus,'}','{',' ')
          Exit
        Endif
        i = m.i + 1
      Enddo
    Else
      fld_txt = m.fld_txt + m.fld_kus
    Endif
  Endfor
Endif
*--------------------------------------------------------------------------------------------
* разбор названия
*--------------------------------------------------------------------------------------------
fld_txt=Chrtran(Alltrim(m.fld_txt),"“”",'""')    && с сохранением регистра
fld_teg=Upper(Chrtran(m.fld_txt," ",""))      && без регистра и пробелов для обработки тегов
If m.rzd_type=8 And Left(m.fld_teg,9)#"REP:START"  && если обнаружен знак [ в постоянной части отчета
  Return 0                    && продолжаем сканирование как будто ничего не было
Endif
Do Case
Case Left(m.fld_teg,9)=="REP:START"  && начало отчета
  ret_tags=PROV_TAGS(1)
Case Left(m.fld_teg,8)=="REP:CON="  && регистрация нового контейнера
  ret_tags=PROV_TAGS(10)
  If m.ret_tags=1
    fld_txt=Upper(m.fld_txt)  && убираем регистрозависимость из индексов, условий и сортировок
    tbl_count=m.tbl_count+1
    tbl__alia=''
    tbl__key=''
    tbl__ord=''
    tbl__des=0
    For i=1 To 10
      tbl_txt=Alltrim(Getwordnum(Substr(m.fld_txt,5),m.i,"|"))
      tbl_dat=Alltrim(Substr(m.tbl_txt,At("=",m.tbl_txt)+1))
      If Left(m.tbl_dat,1)=="&"
        Try
          tbl_dat=Alltrim(Evaluate(Substr(m.tbl_dat,2)))
        Catch
          ret_tags=-1
          rep_errs='Неверно описан тег [CON] - нет переменной, содержащей настройки контейнера!'
        Endtry
        If m.ret_tags=-1
          Return -1
        Endif
      Endif
      Do Case
      Case Upper(Left(Chrtran(m.tbl_txt," ",""),4))=="CON="
        tbl__alia=m.tbl_dat
      Case Upper(Left(Chrtran(m.tbl_txt," ",""),4))=="KEY="
        tbl__key=m.tbl_dat
      Case Upper(Left(Chrtran(m.tbl_txt," ",""),4))=="ORD="
        If Upper(Alltrim(Getwordnum(m.tbl_dat,1,":")))=="DESC"
          tbl__des=1
          tbl__ord=Alltrim(Substr(m.tbl_dat,At(":",m.tbl_dat)+1))
        Else
          tbl__ord=m.tbl_dat
        Endif
      Endcase
    Endfor
    If Empty(m.tbl__alia)
      ret_tags=0
    Else
      Insert Into _rtftables (tnomer,ALINOW,ALIKEY,ALIORD,ALIDES) ;
        VALUES (m.tbl_count,m.tbl__alia,m.tbl__key,m.tbl__ord,m.tbl__des)
      ali_kolv=m.ali_kolv+1
      ali_mass(m.ali_kolv)=m.tbl_count  && массив стек алиасов
    Endif
  Endif
Case Left(m.fld_teg,8)=="REP:ALI="  && регистрация новой таблицы
  ret_tags=PROV_TAGS(2)
  If m.ret_tags=1
    fld_txt=Upper(m.fld_txt)  && убираем регистрозависимость из индексов, условий и сортировок
    tbl_count=m.tbl_count+1
    tbl__alia=''
    tbl__key=''
    tbl__usl=''
    tbl__ord=''
    tbl__add=0
    tbl__des=0
    tbl__utp=0
    For i=1 To 10
      tbl_txt=Alltrim(Getwordnum(Substr(m.fld_txt,5),m.i,"|"))
      tbl_dat=Alltrim(Substr(m.tbl_txt,At("=",m.tbl_txt)+1))
      If Left(m.tbl_dat,1)=="&"
        Try
          tbl_dat=Alltrim(Evaluate(Substr(m.tbl_dat,2)))
        Catch
          ret_tags=-1
          rep_errs='Неверно описан тег [ALI] - нет переменной, содержащей настройки таблицы!'
        Endtry
        If m.ret_tags=-1
          Return -1
        Endif
      Endif
      Do Case
      Case Upper(Left(Chrtran(m.tbl_txt," ",""),4))=="ALI="
        tbl__alia=m.tbl_dat
      Case Upper(Left(Chrtran(m.tbl_txt," ",""),4))=="KEY="
        tbl__key=m.tbl_dat
      Case Upper(Left(Chrtran(m.tbl_txt," ",""),4))=="USL="
        tbl__usl=m.tbl_dat
      Case Upper(Left(Chrtran(m.tbl_txt," ",""),4))=="USL$"
        tbl__usl=Alltrim(Substr(m.tbl_txt,At("$",m.tbl_txt)+1))
        tbl__utp=1
      Case Upper(Left(Chrtran(m.tbl_txt," ",""),4))=="ORD="
        If Upper(Alltrim(Getwordnum(m.tbl_dat,1,":")))=="DESC"
          tbl__des=1
          tbl__ord=Alltrim(Substr(m.tbl_dat,At(":",m.tbl_dat)+1))
        Else
          tbl__ord=m.tbl_dat
        Endif
      Case Upper(Left(Chrtran(m.tbl_txt," ",""),4))=="ADD="
        tbl__add=Val(m.tbl_dat)
      Endcase
    Endfor
    If Empty(m.tbl__alia)
      ret_tags=0
    Else
      Insert Into _rtftables (tnomer,ALINOW,ALIKEY,ALIUSL,ALIORD,ALIADD,ALIDES,ALIUTP) ;
        VALUES (m.tbl_count,m.tbl__alia,m.tbl__key,m.tbl__usl,m.tbl__ord,m.tbl__add,m.tbl__des,m.tbl__utp)
      ali_kolv=m.ali_kolv+1
      ali_mass(m.ali_kolv)=m.tbl_count  && массив стек алиасов
    Endif
  Endif
Case Left(m.fld_teg,8)=="REP:GRP="  && группировка по таблице
  ret_tags=PROV_TAGS(3)
  If m.ret_tags=1
    Local grp_find,grp_flds
    grp_find=0  && количество открытых групп (глубина вложенности)
    For i=m.tag_kolv To 1 Step -1
      Do Case
      Case tag_mass(m.i)=2
        Exit
      Case tag_mass(m.i)=3
        grp_find=m.grp_find+1
      Endcase
    Endfor
    rzd_oldt=-1          && сбрасываем тип предыдущего раздела, чтобы новая группа посчиталась с новым номером
    fld_txt=Upper(m.fld_txt)  && убираем регистрозависимость из индексов, условий и сортировок
    tbl_dat=Alltrim(Substr(m.fld_txt,At("=",m.fld_txt)+1))
    If Left(m.tbl_dat,1)=="&"
      Try
        tbl_dat=Alltrim(Evaluate(Substr(m.tbl_dat,2)))
      Catch
        ret_tags=-1
        rep_errs='Неверно описан тег [GRP] - нет переменной, содержащей настройки группы!'
      Endtry
      If m.ret_tags=-1
        Return -1
      Endif
    Endif
    If Seek(ali_mass(m.ali_kolv),"_rtftables","k1")
      grp_flds="GR"+Alltrim(Str(m.grp_find))+"NOW"
      Replace &grp_flds With m.tbl_dat In _rtftables
    Endif
  Endif
Case Left(m.fld_teg,10)=="REP:DETAIL"
  ret_tags=PROV_TAGS(4)
Case Left(m.fld_teg,13)=="REP:ENDDETAIL"
  ret_tags=PROV_TAGS(5)
Case Left(m.fld_teg,12)=="REP:ENDGROUP"
  ret_tags=PROV_TAGS(6)
  rzd_oldt=-1          && сбрасываем тип предыдущего раздела, чтобы новый конец группы посчитался с новым номером
Case Left(m.fld_teg,12)=="REP:ENDALIAS"
  ret_tags=PROV_TAGS(7)
  If m.ret_tags=1
    ali_mass(m.ali_kolv)=''
    ali_kolv=m.ali_kolv-1
  Endif
Case Left(m.fld_teg,10)=="REP:ENDCON"
  ret_tags=PROV_TAGS(11)
Case Left(m.fld_teg,9)=="REP:FINAL"
  ret_tags=PROV_TAGS(8)
Case Left(m.fld_teg,11)=="REP:ENDPAGE"
  ret_tags=PROV_TAGS(12)
Case Left(m.fld_teg,8)=="REP:CASE"
  ret_tags=PROV_TAGS(13)
Case Left(m.fld_teg,13)=="REP:OTHERWISE"
  ret_tags=PROV_TAGS(14)
Case Left(m.fld_teg,11)=="REP:ENDCASE"
  ret_tags=PROV_TAGS(15)
Otherwise  && поле или функция для подстановки
  ret_tags=PROV_TAGS(9)
Endcase
If m.ret_tags=-1
  Return -1
Endif
obj_body=m.fld_txt
Return m.len_block
*############################################################################################
*############################################################################################
*############################################################################################
Function PROV_TAGS  && отслеживание стека вложенности тегов отчета в массиве tag_mass
Parameters tag_nomer
*  1 - Заголовок отчета
*  2 - Заголовок таблицы
*  3 - Заголовок группы
*  4 - Детайл
*  5 - Подвал группы
*  6 - Подвал таблицы
*  7 - Подпись отчета
*  8 - Постоянная часть отчета
*  9 - Поле или функция для подстановки
* 10 - Начало контейнера
* 11 - Конец контейнера
* 12 - Конец страницы
* 13 - Начало CASE
* 14 - Начало OTHERWISE
* 15 - Конец CASE
*--------------------------------------------------------------------------------------------
Local i,tbl_find,grp_find,dtl_find,con_find
tbl_find=0  && признак найденной таблицы
grp_find=0  && количество найденных групп
dtl_find=0  && признак найденной detail
con_find=0  && признак найденного контейнера
For i=m.tag_kolv To 1 Step -1
  Do Case
  Case tag_mass(m.i)=10
    con_find=1
  Case tag_mass(m.i)=2
    tbl_find=1
  Case tag_mass(m.i)=3 And m.tbl_find=0
    grp_find=m.grp_find+1
  Case tag_mass(m.i)=4 And m.tbl_find=0
    dtl_find=1
  Endcase
Endfor
Do Case
Case Inlist(m.tag_nomer,1)  && добавление Заголовок отчета
  If Ascan(tag_mass,m.tag_nomer)#0
    rep_errs='Повторно описан тег [Заголовок отчета]!'
    Return -1
  Endif
  tag_kolv=m.tag_kolv+1
  tag_mass(m.tag_kolv)=m.tag_nomer
Case Inlist(m.tag_nomer,2)  && добавление Заголовок таблицы
  If m.tbl_find=1 And m.dtl_find=0  && объявлена новая таблица без объявления DETAIL - добавляем
    tag_kolv=m.tag_kolv+1
    tag_mass(m.tag_kolv)=4
  Endif
  tag_kolv=m.tag_kolv+1
  tag_mass(m.tag_kolv)=m.tag_nomer
Case Inlist(m.tag_nomer,3)  && добавление Заголовок группы
  Do Case
  Case m.dtl_find=1  && найдена DETAIL
    rep_errs='Неверно описан тег [Заголовок группы] - в DETAIL!'
    Return -1
  Case m.grp_find=6  && найдена группа
    rep_errs='Неверно описан тег [Заголовок группы] - превышена максимальная вложенность групп!'
    Return -1
  Case m.tbl_find=0  && не найдена таблица
    rep_errs='Неверно описан тег [Заголовок группы] - не найдена таблица!'
    Return -1
  Endcase
  tag_kolv=m.tag_kolv+1
  tag_mass(m.tag_kolv)=m.tag_nomer
Case Inlist(m.tag_nomer,4)  && добавление Детайл
  Do Case
  Case m.dtl_find=1  && найдена DETAIL
    rep_errs='Повторно описан тег [DETAIL]!'
    Return -1
  Case m.tbl_find=0  && не найдена таблица
    rep_errs='Неверно описан тег [DETAIL] - не найдена таблица!'
    Return -1
  Endcase
  tag_kolv=m.tag_kolv+1
  tag_mass(m.tag_kolv)=m.tag_nomer
*--------------------------------------------------------------------------------------------
Case Inlist(m.tag_nomer,5)  && закрытие тега DETAIL
  Do Case
  Case m.dtl_find=0  && не найдена DETAIL
    rep_errs='Неверно описан тег [ENDDETAIL] - не найден открытый тег [DETAIL]!'
    Return -1
  Case m.tbl_find=0  && не найдена таблица
    rep_errs='Неверно описан тег [ENDDETAIL] - не найдена таблица!'
    Return -1
  Endcase
  tag_mass(m.tag_kolv)=0
  tag_kolv=m.tag_kolv-1
Case Inlist(m.tag_nomer,6)  && закрытие тега группы
  Do Case
  Case m.grp_find=0  && не найдена группа
    rep_errs='Неверно описан тег [ENDGROUP] - не найдена открытая группа!'
    Return -1
  Case m.tbl_find=0  && не найдена таблица
    rep_errs='Неверно описан тег [ENDGROUP] - не найдена таблица!'
    Return -1
  Endcase
  For i=1 To 1+m.dtl_find    && найдена DETAIL
    tag_mass(m.tag_kolv)=0  && автозакрытие подчиненных тегов
    tag_kolv=m.tag_kolv-1
  Endfor
Case Inlist(m.tag_nomer,7)  && закрытие тега таблицы
  Do Case
  Case m.tbl_find=0  && не найдена таблица
    rep_errs='Неверно описан тег [ENDALIAS] - не найдена открытая таблица!'
    Return -1
  Endcase
  For i=1 To 1+m.dtl_find+m.grp_find  && найдена DETAIL или группа
    tag_mass(m.tag_kolv)=0      && автозакрытие подчиненных тегов
    tag_kolv=m.tag_kolv-1
  Endfor
Case Inlist(m.tag_nomer,8)  && закрытие Постоянная часть отчета
  Do Case
  Case m.con_find=1  && найден контейнер
    rep_errs='Неверно описан тег [FINAL] - не закрыт тег контейнер!'
    Return -1
  Endcase
  tag_mass=0
  tag_kolv=0
Case Inlist(m.tag_nomer,9)  && Поле или функция для подстановки
  If Ascan(tag_mass,1)=0  && не открыт тег отчета
    rep_errs='Не открыт тег [START]!'
    Return -1
  Endif
Case Inlist(m.tag_nomer,10)  && добавление контейнера
  Do Case
  Case m.dtl_find=1  && найдена DETAIL
    rep_errs='Неверно описан тег [CON] - найдена открытая DETAIL!'
    Return -1
  Case m.grp_find#0  && найдена группа
    rep_errs='Неверно описан тег [CON] - найдена открытая группа!'
    Return -1
  Case m.tbl_find=1  && Найдена таблица
    rep_errs='Неверно описан тег [CON] - найдена открытая таблица!'
    Return -1
  Endcase
  tag_kolv=m.tag_kolv+1
  tag_mass(m.tag_kolv)=m.tag_nomer
Case Inlist(m.tag_nomer,11)  && закрытие контейнера
  Do Case
  Case m.con_find=0  && НЕ найден контейнер
    rep_errs='Неверно описан тег [ENDCON] - не найден открытый контейнер!'
    Return -1
  Case m.dtl_find=1  && найдена DETAIL
    rep_errs='Неверно описан тег [ENDCON] - найдена открытая DETAIL!'
    Return -1
  Case m.grp_find#0  && найдена группа
    rep_errs='Неверно описан тег [ENDCON] - найдена открытая группа!'
    Return -1
  Case m.tbl_find=1  && Найдена таблица
    rep_errs='Неверно описан тег [ENDCON] - найдена открытая таблица!'
    Return -1
  Endcase
  tag_mass(m.tag_kolv)=0
  tag_kolv=m.tag_kolv-1
Case Inlist(m.tag_nomer,12)  && конец страницы
***
Case Inlist(m.tag_nomer,13)  && CASE
***
Case Inlist(m.tag_nomer,14)  && OTHERWISE
***
Case Inlist(m.tag_nomer,15)  && ENDCASE
***
Otherwise
  rep_errs='Неверно описана структура шаблона!'
  Return -1
Endcase
obj_type=m.tag_nomer
rzd_type=Iif(m.tag_kolv=0,8,tag_mass(m.tag_kolv))
Return 1
*############################################################################################
*############################################################################################
*############################################################################################
Function ENCODE_SYMBOLS  && замена русских букв на HEX-коды
Lparameters rus_text
Local i,kus_text,out_hex
out_hex=''
Set Textmerge On
Set Textmerge To Memvar out_hex Additive Noshow
For i=1 To Len(m.rus_text)
  kus_text=Substr(m.rus_text, m.i, 1)
    \<<Iif(ASC(m.kus_text)<127, m.kus_text, LOWER("\'"+RIGHT(TRANSFORM(ASC(m.kus_text),'@0'),2)))>>
Next
Set Textmerge Off
Set Textmerge To
Return m.out_hex
*############################################################################################
*############################################################################################
*############################################################################################
Function NUM_RAZDEL  && разделить разряды числа пробелами
Parameters in_hislo  && число
Local i,len_hislo
in_hislo=Alltrim(Padl(m.in_hislo,30))
len_hislo=Len(Iif("."$m.in_hislo,Getwordnum(m.in_hislo,1,"."),m.in_hislo))
For i=m.len_hislo-2 To 2 Step -3
  in_hislo=Stuff(m.in_hislo,m.i,0," ")
Endfor
Return Alltrim(m.in_hislo)
*############################################################################################
*############################################################################################
*############################################################################################
Function REP_DATAPROP  && выводит дату прописью - {01.01.2000} в виде "01 января 2000 г."
Parameters tmpdata
Return Chrtran(Str(Day(m.tmpdata),2)," ","0")+" "+REP_GET_MES(Month(m.tmpdata),1)+" "+Str(Year(m.tmpdata),4)+" г."
*############################################################################################
*############################################################################################
*############################################################################################
Function REP_PERNAME  && описание периода, заданного в виде строки '200501'
Parameters period_now,period_cfg
* period_now - строка в виде "200901" (год+месяц) или "20091" (год+номер квартала или полугодия)
* period_cfg - доп настройка
*  Q - квартал
*  H - полугодие
*-ПРИМЕР ЗАПУСКА ----------------------------------------------------------------------------
* ? REP_PERNAME("200903")
*--------------------------------------------------------------------------------------------
If Vartype(m.period_cfg)#"C"
  period_cfg=''
Endif
If Inlist(Vartype(m.period_now),"D","T")
  period_now=Left(Dtos(m.period_now),6)
Endif
Local ret_pername
If Empty(m.period_now)
  period_now=Left(Dtos(Date()),6)
Else
  period_now=Left(m.period_now,6)
Endif
Do Case
Case "H"$m.period_cfg
  ret_pername=Iif(Len(m.period_now)=5,Right(m.period_now,1),Str(Ceiling(Val(Right(m.period_now,2))/6),1))+' полугодие '+Left(m.period_now,4)+" г."
Case "Q"$m.period_cfg
  ret_pername=Iif(Len(m.period_now)=5,Right(m.period_now,1),Str(Ceiling(Val(Right(m.period_now,2))/3),1))+' квартал '+Left(m.period_now,4)+" г."
Case "P"$m.period_cfg  && падеж - январь > января
  ret_pername=REP_GET_MES(Val(Right(m.period_now,2)),1)+' '+Left(m.period_now,4)+" г."
Otherwise
  ret_pername=REP_GET_MES(Val(Right(m.period_now,2)))+' '+Left(m.period_now,4)+" г."
Endcase
Return m.ret_pername
*############################################################################################
*############################################################################################
*############################################################################################
Function REP_GET_MES  && возвращает наименование месяца в нужном падеже
Parameters mes_nom,kak  && ret_mes - номер месяца, kak =0/1, 1 - в виде января и т.д.
*-ПРИМЕР ЗАПУСКА ----------------------------------------------------------------------------
* ? REP_GET_MES(1)
*--------------------------------------------------------------------------------------------
If Vartype(m.kak)#'N'
  kak=0
Endif
Local ret_mes
ret_mes=''
Dimension naim_mes(12)
naim_mes(1)="Январь"
naim_mes(2)="Февраль"
naim_mes(3)="Март "
naim_mes(4)="Апрель"
naim_mes(5)="Май"
naim_mes(6)="Июнь"
naim_mes(7)="Июль"
naim_mes(8)="Август "
naim_mes(9)="Сентябрь"
naim_mes(10)="Октябрь"
naim_mes(11)="Ноябрь"
naim_mes(12)="Декабрь"
ret_mes=naim_mes(m.mes_nom)
If m.kak=1
  If Inlist(m.mes_nom,3,8)
    ret_mes=Left(m.ret_mes,Len(m.ret_mes)-1)+"а"
  Else
    ret_mes=Left(m.ret_mes,Len(m.ret_mes)-1)+"я"
  Endif
Endif
Return m.ret_mes
*############################################################################################
*############################################################################################
*############################################################################################
Function REP_NUM_PROP  && цифра прописью, при nDrobn=0 пишет рубли и копейки, >0 - целые и дробные
Parameter nSumma,nDrobn
If Vartype(m.nSumma)#"N" && Если не задан параметр
  nSumma = 0
Endif
If Vartype(m.nDrobn)#"N" && Если не задан параметр
  nDrobn = 0
Else
  nSumma=Round(m.nSumma,m.nDrobn)
Endif
nDrobn=Iif(m.nDrobn>3,3,m.nDrobn)
Private cSumma
* k - копейки
If m.nDrobn=0
  cSumma = Transform(M.nSumma,'9,9,,9,,,,,,9,9,,9,,,,,9,9,,9,,,,9,9,,9,,,.99')+'k'
  cSumma = Iif(Substr(m.cSumma,Len(m.cSumma)-3,1)=='.',m.cSumma,Stuff(m.cSumma,Len(m.cSumma)-3,1,"."))  && если SET POINT = ",", восстанавливаем точку
Else
  cSumma = Transform(Floor(M.nSumma),'9,9,,9,,,,,,9,9,,9,,,,,9,9,,9,,,,9,9,,9,,,.')
  cSumma = Iif(Right(m.cSumma,1)=='.',m.cSumma,Left(m.cSumma,Len(m.cSumma)-1)+".")            && если SET POINT = ",", восстанавливаем точку
  cSumma = m.cSumma + Alltrim(Str((M.nSumma-Floor(M.nSumma))*10^m.nDrobn,3))
Endif
cSumma=Chrtran(cSumma,Chr(160),",")    && лечение глюка: в EXE файле меняет запятые на символ со значением 160

* t - тысячи; m - миллионы; M - миллиарды
cSumma = Strtran(M.cSumma, ',,,,,,', 'eM')
cSumma = Strtran(M.cSumma, ',,,,,',  'em')
cSumma = Strtran(M.cSumma, ',,,,',   'et')

* e - единицы; d - десятки; c - сотни
cSumma = Strtran(M.cSumma, ',,,', 'e')
cSumma = Strtran(M.cSumma, ',,',  'd')
cSumma = Strtran(M.cSumma, ',',   'c')

cSumma = Strtran(M.cSumma, '0c0d0et', '')
cSumma = Strtran(M.cSumma, '0c0d0em', '')
cSumma = Strtran(M.cSumma, '0c0d0eM', '')

cSumma = Strtran(M.cSumma, '0c', '')
cSumma = Strtran(M.cSumma, '1c', 'сто ')
cSumma = Strtran(M.cSumma, '2c', 'двести ')
cSumma = Strtran(M.cSumma, '3c', 'триста ')
cSumma = Strtran(M.cSumma, '4c', 'четыреста ')
cSumma = Strtran(M.cSumma, '5c', 'пятьсот ')
cSumma = Strtran(M.cSumma, '6c', 'шестьсот ')
cSumma = Strtran(M.cSumma, '7c', 'семьсот ')
cSumma = Strtran(M.cSumma, '8c', 'восемьсот ')
cSumma = Strtran(M.cSumma, '9c', 'девятьсот ')

cSumma = Strtran(M.cSumma, '1d0e', 'десять ')
cSumma = Strtran(M.cSumma, '1d1e', 'одиннадцать ')
cSumma = Strtran(M.cSumma, '1d2e', 'двенадцать ')
cSumma = Strtran(M.cSumma, '1d3e', 'тринадцать ')
cSumma = Strtran(M.cSumma, '1d4e', 'четырнадцать ')
cSumma = Strtran(M.cSumma, '1d5e', 'пятнадцать ')
cSumma = Strtran(M.cSumma, '1d6e', 'шестнадцать ')
cSumma = Strtran(M.cSumma, '1d7e', 'семьнадцать ')
cSumma = Strtran(M.cSumma, '1d8e', 'восемнадцать ')
cSumma = Strtran(M.cSumma, '1d9e', 'девятнадцать ')

cSumma = Strtran(M.cSumma, '0d', '')
cSumma = Strtran(M.cSumma, '2d', 'двадцать ')
cSumma = Strtran(M.cSumma, '3d', 'тридцать ')
cSumma = Strtran(M.cSumma, '4d', 'сорок ')
cSumma = Strtran(M.cSumma, '5d', 'пятьдесят ')
cSumma = Strtran(M.cSumma, '6d', 'шестьдесят ')
cSumma = Strtran(M.cSumma, '7d', 'семьдесят ')
cSumma = Strtran(M.cSumma, '8d', 'восемьдесят ')
cSumma = Strtran(M.cSumma, '9d', 'девяносто ')

cSumma = Strtran(M.cSumma, '0e', '')
cSumma = Strtran(M.cSumma, '5e', 'пять ')
cSumma = Strtran(M.cSumma, '6e', 'шесть ')
cSumma = Strtran(M.cSumma, '7e', 'семь ')
cSumma = Strtran(M.cSumma, '8e', 'восемь ')
cSumma = Strtran(M.cSumma, '9e', 'девять ')

cSumma = Strtran(M.cSumma, '1e.', Iif(m.nDrobn=0,'один рубль ','одна целая '))
cSumma = Strtran(M.cSumma, '2e.', Iif(m.nDrobn=0,'два рубля ','две целых '))
cSumma = Strtran(M.cSumma, '3e.', Iif(m.nDrobn=0,'три рубля ','три целых '))
cSumma = Strtran(M.cSumma, '4e.', Iif(m.nDrobn=0,'четыре рубля ','четыре целых '))
cSumma = Strtran(M.cSumma, '1et', 'одна тысяча ')
cSumma = Strtran(M.cSumma, '2et', 'две тысячи ')
cSumma = Strtran(M.cSumma, '3et', 'три тысячи ')
cSumma = Strtran(M.cSumma, '4et', 'четыре тысячи ')
cSumma = Strtran(M.cSumma, '1em', 'один миллион ')
cSumma = Strtran(M.cSumma, '2em', 'два миллиона ')
cSumma = Strtran(M.cSumma, '3em', 'три миллиона ')
cSumma = Strtran(M.cSumma, '4em', 'четыре миллиона ')
cSumma = Strtran(M.cSumma, '1eM', 'один миллиард ')
cSumma = Strtran(M.cSumma, '2eM', 'два миллиарда ')
cSumma = Strtran(M.cSumma, '3eM', 'три миллиарда ')
cSumma = Strtran(M.cSumma, '4eM', 'четыре миллиарда ')

cSumma = Strtran(M.cSumma, '11k', '11 копеек')
cSumma = Strtran(M.cSumma, '12k', '12 копеек')
cSumma = Strtran(M.cSumma, '13k', '13 копеек')
cSumma = Strtran(M.cSumma, '14k', '14 копеек')
cSumma = Strtran(M.cSumma, '1k', '1 копейка')
cSumma = Strtran(M.cSumma, '2k', '2 копейки')
cSumma = Strtran(M.cSumma, '3k', '3 копейки')
cSumma = Strtran(M.cSumma, '4k', '4 копейки')

cSumma = Strtran(M.cSumma, '.', Iif(m.nDrobn=0,'рублей ','целых '))
cSumma = Strtran(M.cSumma, 't', 'тысяч ')
cSumma = Strtran(M.cSumma, 'm', 'миллионов ')
cSumma = Strtran(M.cSumma, 'M', 'миллиардов ')
cSumma = Strtran(M.cSumma, 'k', ' копеек')

If m.nDrobn#0
  Do Case
  Case Right(m.cSumma,1)='1' .And. Right(m.cSumma,2)#'11'
    cSumma = m.cSumma+Getwordnum(' десят| сот| тысячн',m.nDrobn,'|')+'ая'
  Case Between(Right(m.cSumma,1),'2','4') .And. !Between(Right(m.cSumma,2),'12','14')
    cSumma = m.cSumma+Getwordnum(' десят| сот| тысячн',m.nDrobn,'|')+'ые'
  Otherwise
    cSumma = m.cSumma+Getwordnum(' десят| сот| тысячн',m.nDrobn,'|')+'ых'
  Endcase
Endif

cSumma = Iif(M.nSumma < 1,'ноль '+Allt(M.cSumma),M.cSumma)
cSumma=Allt(Iif(M.nSumma < 10**12, M.cSumma, Alltrim(Str(M.nSumma,20,2))))
cSumma=Upper(Left(m.cSumma,1))+Lower(Substr(m.cSumma,2))
Return m.cSumma
*############################################################################################
*############################################################################################
*############################################################################################
Function PrintAny  && Печать WORD документов
Parameters docfile,prnname,prcopies,prpages,rep_config
* docfile  - Файл для печати
* prnname  - Принтер (по умолчанию = DEFAULT)
* prcopies  - Копий (по умолчанию =1)
* prpages  - Диапазон листов для печати | BOOK - печать книжкой | SIDE - печать поочередно нечетных и четных страниц
* rep_config- конфигурация
*  [HIDE]  - не показывать сообщения пользователю
*--------------------------------------------------------------------------------------------
If Vartype(m.prnname)#"C"
  prnname=''
Endif
If Vartype(m.prcopies)#"N" Or m.prcopies<=0
  prcopies=1
Endif
If Vartype(m.prpages)#"C" Or (!Empty(Chrtran(m.prpages,"1234567890,- ","")) And !Inlist(Alltrim(Upper(m.prpages)),"BOOK","SIDE"))
  prpages=''
Endif
If Vartype(m.rep_config)#"C"
  rep_config=''
Endif
If !File(m.docfile)
  Return 0
Endif
docfile=Fullpath(m.docfile)
Local loWord, loBook, kollist, errprint, openword
errprint=0
openword=0
Declare Sleep In kernel32 Integer dwMilliseconds
Try
  loWord=Createobject('Word.Application')
  With loWord
    .Visible=.F.
    openword=1          && добрались до этой строки - значит будем закрывать WORD при завершении
    loBook = .Documents.Open(m.docfile)
    If !Empty(m.prnname) And Aprinters(gaPrinters)>0 And Ascan(gaPrinters,Alltrim(prnname))#0  && проверка наличия целевого принтера
      .ActivePrinter=m.prnname
    Endif
    Wait Window Iif("[HIDE]"$Upper(m.rep_config),"","Идет печать...") Nowait Noclear
    Do Case
    Case Alltrim(Upper(m.prpages))=="BOOK"                    && печать книжкой
      kollist=.ActiveDocument.ActiveWindow.Panes(1).Pages.Count      && кол-во листов в документе
      If m.kollist%2=1                            && нечетное кол-во листов
        .ActiveDocument.Range.Select
        .Selection.EndKey(6)
        .Selection.TypeParagraph                    && добавляем новый параграф с очищенным форматированием
        .Selection.ClearFormatting
        kollist = .ActiveDocument.ActiveWindow.Panes(1).Pages.Count    && кол-во листов в документе
        Do While m.kollist%4#0
          .Selection.InsertBreak(2)                  && добавляем лист, чтобы было кол-во/4=0
          kollist = .ActiveDocument.ActiveWindow.Panes(1).Pages.Count    && кол-во листов в документе
        Enddo
      Endif
      prpages=''
      For i=1 To Ceiling(m.kollist/2) Step 2
        prpages=Iif(Empty(m.prpages),"",m.prpages+",")+Transform(m.kollist+m.kollist%2-(m.i-1))+","+Transform(m.i)
      Endfor
      .ActiveDocument.PrintOut(,,4,,,,,m.prcopies,m.prpages,,,.T.,,,2,1)  && печать
      Do While !Empty(.Application.BackgroundPrintingStatus)  && ждем, пока напечатает
        Sleep(1000)
      Enddo
      Wait Clear
      If Messagebox("Дождитесь, пока принтер не закончит печатать и положите пачку отпечатанных листов"+Chr(13)+"так, чтобы он начал печатать на чистой стороне листа."+Chr(13)+Chr(13)+"Продолжить печать?",36,"Внимание!")=6
        Wait Window Iif("[HIDE]"$Upper(m.rep_config),"","Идет печать...") Nowait Noclear
        prpages=''
        For i=2 To Ceiling(m.kollist/2) Step 2
          prpages=Iif(Empty(m.prpages),"",m.prpages+",")+Transform(m.i)+","+Transform(m.kollist+m.kollist%2-(m.i-1))
        Endfor
        .ActiveDocument.PrintOut(,,4,,,,,m.prcopies,m.prpages,,,.T.,,,2,1)  && печать
        Do While !Empty(.Application.BackgroundPrintingStatus)  && ждем, пока напечатает
          Sleep(1000)
        Enddo
      Endif
    Case Alltrim(Upper(m.prpages))=="SIDE"                    && печать книжкой
      kollist = .ActiveDocument.ActiveWindow.Panes(1).Pages.Count      && кол-во листов в документе
      prpages=''
      For i=1 To m.kollist Step 2
        prpages=m.prpages+Iif(Empty(m.prpages),"",",")+Transform(m.i)
      Endfor
      .ActiveDocument.PrintOut(,,4,,,,,m.prcopies,m.prpages,,,.T.)  && печать указанных листов
      Do While !Empty(.Application.BackgroundPrintingStatus)  && ждем, пока напечатает
        Sleep(1000)
      Enddo
      Wait Clear
      If Messagebox("Дождитесь, пока принтер не закончит печатать и положите пачку отпечатанных листов"+Chr(13)+"так, чтобы он начал печатать на чистой стороне листа."+Chr(13)+Chr(13)+"Продолжить печать?",36,"Внимание!")=6
        Wait Window Iif("[HIDE]"$Upper(m.rep_config),"","Идет печать...") Nowait Noclear
        prpages=''
        For i=2 To m.kollist Step 2
          prpages=m.prpages+Iif(Empty(m.prpages),"",",")+Transform(m.i)
        Endfor
        .ActiveDocument.PrintOut(,,4,,,,,m.prcopies,m.prpages,,,.T.)  && печать указанных листов
      Endif
    Case !Empty(m.prpages)
      .ActiveDocument.PrintOut(,,4,,,,,m.prcopies,m.prpages,,,.T.)  && печать указанных листов
    Otherwise
      .ActiveDocument.PrintOut(,,,,,,,m.prcopies,,,,.T.)      && печать всего документа
    Endcase
    Do While !Empty(.Application.BackgroundPrintingStatus)      && ждем, пока напечатает
      Sleep(1000)
    Enddo
    loWord.Quit(0)
  Endwith
  loWord= Null
Catch To goto_error
  errprint=1
  If m.openword=1
    loWord.Quit(0)
    loWord= Null
  Endif
Endtry
Clear Dlls "Sleep"
Release m.loWord
Return Iif(m.errprint=1,-1,1)
*############################################################################################
*############################################################################################
*############################################################################################
Function SPLIT_REPORT  && Разделение отчета на несколько файлов
Parameters f_shabl, f_othet, rep_config, ali_reps
*  f_othet    - файл результата, должен иметь символ "%" для вставки номера файла, например "REP%.RTF"
*  all_rows  - общее количество записей в основной таблице
*  rep_config  - должен содержать настройки для отчета и дополнительно параметр [SPLIT=*], где "*" - MAX количество записей в томе.
*        - может содержать параметр [STOMS=1,2,5-8] для формирования только указанных томов.
*   ali_reps  - Список алиасов, которые составляют разделы отчета через "|"
*--------------------------------------------------------------------------------------------
* Описание применения:
*--------------------------------------------------------------------------------------------
* Данная функция может быть применена:
*    1 - для формирования многотомных (разбитых на N файлов) отчетов.
*    2 - для формирования результирующего файла, размером более 2 Гбт - для этого сформированные тома сшиваются в один с помощью
*    команды COPY Файл1+Файл2+ФайлN Файлрезультат. При этом не забывать добавлять условия:
*      для шапки отчета:   [REP:CASE=m._rep_tekl=1]
*      для хвоста отчета:  [REP:CASE=m._rep_tekl=m._rep_maxl]
*--------------------------------------------------------------------------------------------
* Ограничения:
*--------------------------------------------------------------------------------------------
* 1. Основные таблицы в отчете должна быть объявленны как [REP:ALI=Ваш алиас|USL=_rep_uslv(№ таблицы)],
*    где _rep_uslv(№ таблицы) - условия для каждой таблицы, формируемые в этой функции
* 2. Основные таблицы не должны содержать дополнительных фильтров
*--------------------------------------------------------------------------------------------
Local i,j,tmp_name,ret_error,tom_rows,f_conftxt,tom_count,tek_rows,tek_tabl,ali_rows,now_rows,tek_gran,tom_only
tom_rows=0
tom_only=''
For i=1 To Getwordcount(m.rep_config,"]")
  f_conftxt=Alltrim(Getwordnum(m.rep_config,m.i,"]"))
  Do Case
  Case Alltrim(Upper(Left(m.f_conftxt,7)))=="[SPLIT="
    tom_rows=Val(Alltrim(Substr(m.f_conftxt,At("=",m.f_conftxt)+1)))
  Case Alltrim(Upper(Left(m.f_conftxt,7)))=="[STOMS="
    tom_only=Alltrim(Substr(m.f_conftxt,At("=",m.f_conftxt)+1))
  Endcase
Endfor
If m.tom_rows=0    && не задан параметр разделения
  Return -1
Endif
*--------------------------------------------------------------------------------------------
Dimension _rep_alia(Getwordcount(m.ali_reps,"|"),2)
all_rows=0
For i=1 To Getwordcount(m.ali_reps,"|")
  _rep_alia(m.i,1)=Alltrim(Getwordnum(m.ali_reps,m.i,"|"))
  If !Used(_rep_alia(m.i,1))
    Return -2
  Endif
  Select (_rep_alia(m.i,1))
  Count To _rep_alia(m.i,2)
  all_rows=m.all_rows+_rep_alia(m.i,2)
Endfor
*--------------------------------------------------------------------------------------------
tom_count=Ceiling(m.all_rows/m.tom_rows)  && количество томов
Dimension _rep_recn(m.tom_count,Getwordcount(m.ali_reps,"|"))  && матрица диапазонов строк для всех таблиц по томам
tek_rows=0                  && общее количество обработанных записей
tek_tabl=1                  && общее количество обработанных таблиц
ali_rows=0                  && количество обработанных записей текущей таблицы в предыдущем томе
now_rows=0                  && количество обработанных записей за текущую итерацию
*--------------------------------------------------------------------------------------------
For i=1 To m.tom_count                      && для каждого тома
  For j=1 To Getwordcount(m.ali_reps,"|")            && по каждой таблице формируем диапазоны записей
    tek_gran=m.i*m.tom_rows-m.tek_rows            && записей до разделения в текущем томе
    If m.j=m.tek_tabl                    && № таблицы = текущей
      If _rep_alia(m.tek_tabl,2)-m.ali_rows<=m.tek_gran  && кол-во необработанных записей в таблице меньше либо равно кол-ву записей до разделения тома
        now_rows=_rep_alia(m.j,2)-m.ali_rows
        _rep_recn(m.i,m.j)=Alltrim(Str(m.ali_rows+1))+","+Alltrim(Str(_rep_alia(m.j,2)))
        tek_rows=m.tek_rows+m.now_rows
        ali_rows=0                    && обнуляем кол-во
        tek_tabl=m.tek_tabl+1              && переключаем на следующую таблицу
      Else
        now_rows=m.tek_gran
        _rep_recn(m.i,m.j)=Alltrim(Str(m.ali_rows+1))+","+Alltrim(Str(m.ali_rows+m.now_rows))
        tek_rows=m.tek_rows+m.now_rows
        ali_rows=m.ali_rows+m.now_rows
      Endif
    Endif
  Endfor
Endfor
*--------------------------------------------------------------------------------------------
Dimension _rep_uslv(Getwordcount(m.ali_reps,"|"))        && массив условий таблиц для текущего тома
For i=1 To m.tom_count                      && формируем тома
  If !Empty(m.tom_only) And GET_INLIST(m.tom_only,m.i)#1    && заданы тома для формирования и текущий том формировать не нужно
    Loop
  Endif
  For j=1 To Getwordcount(m.ali_reps,"|")            && по каждой таблице формируем условие в этом томе
    _rep_uslv(j)="BETWEEN(RECNO(),"+Iif(Empty(_rep_recn(m.i,m.j)),"0,0",_rep_recn(m.i,m.j))+")"
  Endfor
  tmp_name=Strtran(m.f_othet,"%",Alltrim(Str(m.i)))
  ret_error=RTF_REPORT(m.f_shabl,m.tmp_name,m.rep_config)
  If !Empty(m.ret_error)
    Messagebox(m.ret_error,16,"Ошибка")
    Exit
  Endif
Endfor
Return m.ret_error
*############################################################################################
*############################################################################################
*############################################################################################
Function GET_INLIST  && проверка, относится ли заданное число к диапазону, заданному в виде "1,2,5-8"
Parameters list_str,list_now
* list_str - диапазон
* list_now - число
*--------------------------------------------------------------------------------------------
If Vartype(m.list_str)#"C" Or Vartype(m.list_now)#"N"
  Return -1
Endif
Local i,list_tmp,list_min,list_max
list_min=0
list_max=0
For i=1 To Getwordcount(m.list_str,",")
  list_tmp=Getwordnum(m.list_str,m.i,",")
  If "-"$m.list_tmp
    list_min=Val(Getwordnum(m.list_tmp,1,"-"))
    list_max=Val(Getwordnum(m.list_tmp,2,"-"))
  Else
    list_min=Val(m.list_tmp)
    list_max=m.list_min
  Endif
  If Between(m.list_now,m.list_min,m.list_max)
    Return 1
  Endif
Endfor
Return 0
*############################################################################################
*############################################################################################
*############################################################################################
Function XLS_REPORT  && выгрузка в EXCEL с использованием XML EXCEL шаблона
Parameters f_shabl, f_othet, rep_config
*--------------------------------------------------------------------------------------------
* @ TAS - 2019 г. Все параметры необязательны!
*--------------------------------------------------------------------------------------------
* 1 - f_shabl - файл шаблона
* 2 - f_othet - файл результата
* 3 - rep_config - Конфигурация запуска - может содержать любой набор из нижеперечисленных вариантов:
*  [SHOW]  - показать XLS отчет
*  доп параметры см. в функции RTF_REPORT
*--------------------------------------------------------------------------------------------
* Шаблон EXCEL должен содержать те-же теги, что описаны для WORD, заданные в первой колонке.
* Первая колонка и строки со служебными тегами из готового документа будут удалены!!!
*--------------------------------------------------------------------------------------------
* ? XLS_REPORT("test2.xls","ready.xlsx","[SHOW]")
*--------------------------------------------------------------------------------------------
Local i,j, t_kol, ret_txt, row_txt, row_del, tmp_txt, kol_spt, kol_add
Local all_txt, tek_str, tmp_shabl, tmp_othet, form_ret, row_skip
rep_errs=''   && переменная для ошибки
form_ret=1   && при ошибке принимает отрицательное значение
If Empty(Justpath(m.f_othet))
  m.f_othet=Sys(5)+Curdir()+m.f_othet  && дополняем полным путем, иначе EXCEL не поймет
Endif
If !File(m.f_shabl)
  rep_errs='Не найден файл шаблона!'
  form_ret=-1
Else
  all_txt=Strconv(Filetostr(m.f_shabl),11)
  ret_txt=''  && результат
  row_del=0  && признак удаления строки
  kol_spt=0  && кол-во строк, закрепленных в заголовке
  kol_add=1  && Признак для подсчета kol_spt
  kol_col=0  && кол-во колонок
*--------------------------------------------------------------------------------------------
* Преобразование XML EXCEL файла в шаблон для RTF_REPORT на основе данных первой колонки
*--------------------------------------------------------------------------------------------
  t_kol=Alines(aMyArray, m.all_txt)
  For i=1 To m.t_kol
    tek_str=aMyArray(m.i)
    Do While Occurs("<",m.tek_str)#Occurs(">",m.tek_str) And m.i<=m.t_kol  && собираем строки
      i=m.i+1
      tek_str=m.tek_str+' '+Alltrim(aMyArray(m.i))
    Enddo
    Do Case
    Case Upper(Left(Alltrim(m.tek_str),4))=="<ROW"  && начало строки
      row_txt=Getwordnum(m.tek_str,1," ")
      For j=2 To Getwordcount(m.tek_str," ")
        If !"INDEX="$Upper(Alltrim(Getwordnum(m.tek_str,m.j," ")))  && жестко заданные индексы убираем нафиг
          row_txt=m.row_txt+Iif(Empty(m.row_txt),'',' ')+Alltrim(Getwordnum(m.tek_str,m.j," "))
        Endif
      Endfor
    Case Upper(Left(Alltrim(m.tek_str),5))=="</ROW"  && Конец строки
      ret_txt=m.ret_txt+Chr(13)+m.row_txt
      If row_del=0
        ret_txt=m.ret_txt+Chr(13)+m.tek_str
        kol_spt=m.kol_spt+m.kol_add        && кол-во строк, закрепленных в заголовке
      Endif
      row_del=0
      Loop
    Case Upper(Left(Alltrim(m.tek_str),5))=="<CELL"
      Do Case
      Case m.row_del=1    && удаляем строку
        Loop
      Case "[REP:"$m.tek_str  && служебные строки
        row_del=1
        row_txt=Substr(m.tek_str,At("[REP:",m.tek_str))
        row_txt=Getwordnum(m.row_txt,1,"]")+"]"
        If "[REP:DETAIL]"$m.row_txt  && достигли DETAIL - заголовок закончился
          kol_add=0
        Endif
        row_txt=Strtran(m.row_txt,"&lt;","<")  && в служебных строках восстанавливаем экранированные символы
        row_txt=Strtran(m.row_txt,"&gt;",">")
      Case "[REPVAR"$m.tek_str  && служебные переменные
        row_del=1
        row_txt=Substr(m.tek_str,At("[REPVAR",m.tek_str))
        row_txt=Getwordnum(m.row_txt,1,"]")+"]"
        row_txt=Strtran(m.row_txt,"&lt;","<")  && в служебных строках восстанавливаем экранированные символы
        row_txt=Strtran(m.row_txt,"&gt;",">")
      Otherwise
        Do While !"</Cell>"$m.tek_str
          i=m.i+1
          tek_str=m.tek_str+" "+Alltrim(aMyArray(m.i))
        Enddo
        row_txt=m.row_txt+Iif(Empty(m.row_txt),'',Chr(13))+m.tek_str
      Endcase
    Case Upper(Left(Alltrim(m.tek_str),6))=="<TABLE"
      If "ss:ExpandedColumnCount="$m.tek_str
        For j=1 To Getwordcount(m.tek_str," ")
          If "ss:ExpandedColumnCount="$Getwordnum(m.tek_str,m.j," ")
            kol_col=Int(Val(Chrtran(Substr(Getwordnum(m.tek_str,m.j," "),24),'"','')))-1   && кол-во колонок
            Exit
          Endif
        Endfor
      Endif
      ret_txt=m.ret_txt+Chr(13)+Left(m.tek_str,At("ss:ExpandedRowCount",m.tek_str)-1)
      tmp_txt=Substr(m.tek_str,At("ss:ExpandedRowCount",m.tek_str)) && убираем кол-во строк
      tmp_txt=Alltrim(Substr(m.tmp_txt,At('"',m.tmp_txt,2)+1))
      ret_txt=m.ret_txt+m.tmp_txt
    Case Upper(Left(Alltrim(m.tek_str),7))=="<PANES>" Or Upper(Left(Alltrim(m.tek_str),19))=="<DOCUMENTPROPERTIES" Or Upper(Left(Alltrim(m.tek_str),11))=="<AUTOFILTER" &&OR UPPER(LEFT(ALLTRIM(m.tek_str),7))=="<NAMES>"
      row_del=1                      && теперь будем убирать все строки
    Case Upper(Left(Alltrim(m.tek_str),8))=="</PANES>" Or Upper(Left(Alltrim(m.tek_str),20))=="</DOCUMENTPROPERTIES" Or Upper(Left(Alltrim(m.tek_str),12))=="</AUTOFILTER" &&OR UPPER(LEFT(ALLTRIM(m.tek_str),8))=="</NAMES>"
      row_del=0                      && теперь НЕ будем убирать все строки
    Case Upper(Left(Alltrim(m.tek_str),11))=="<NAMEDRANGE"
      If "Print_Area"$m.tek_str Or "Print_Titles"$m.tek_str  && только некоторые пропускаем
        ret_txt=m.ret_txt+Iif(Empty(m.ret_txt),'',Chr(13))+m.tek_str
      Endif
    Otherwise
      stoplist="<SplitHorizontal>|<TopRowBottomPane>|<ActivePane>|<TopRowVisible>|<LeftColumnVisible>" && уберем эти строки
      row_skip=0
      For j=1 To Getwordcount(m.stoplist,"|")
        stopword=Alltrim(Upper(Getwordnum(m.stoplist,m.j,"|")))
        If Upper(Left(Alltrim(m.tek_str),Len(m.stopword)))==m.stopword
          row_skip=1
        Endif
      Endfor
      If m.row_del=0 And m.row_skip=0  && если не удаляем все строки и не пропускаем
        ret_txt=m.ret_txt+Iif(Empty(m.ret_txt),'',Chr(13))+m.tek_str
      Endif
    Endcase
  Endfor
Endif
*--------------------------------------------------------------------------------------------
* Формирование временного файла с данными в формате XML EXCEL
*--------------------------------------------------------------------------------------------
tmp_shabl=Sys(2023)+'\'+Sys(3)+'.xml'
tmp_othet=Sys(2023)+'\'+Sys(3)+'.xml'
If form_ret=1 And Strtofile(m.ret_txt,m.tmp_shabl)<=0  && сохранение готового шаблона
  rep_errs='Шаблон не содержит данных!'
  form_ret=-1
Endif
If form_ret=1
*    =STRTOFILE(m.ret_txt,'c:\tascold\1.xml')        && для тестирования
  rep_errs=RTF_REPORT(m.tmp_shabl, m.tmp_othet, Strtran(m.rep_config,"[SHOW]","")+"[ENCODE=9][EXCEL]")  && формирование файла с данными
*    =STRTOFILE(FILETOSTR(m.tmp_othet),'c:\tascold\2.xml')  && для тестирования
  If !Empty(rep_errs)
    form_ret=-1
  Endif
Endif
*--------------------------------------------------------------------------------------------
* Сохранение как документа EXCEL и финальные операции
*--------------------------------------------------------------------------------------------
If form_ret=1
  oExcel= Createobject("Excel.Application")
  If Type("oExcel")#"O"
    rep_errs='Не установлен Excel! Отчет не может быть сформирован!'
    form_ret=-1
  Else
    With oExcel
      .DisplayAlerts = .F.
      .Workbooks.OpenXML(m.tmp_othet,,2)
      .Columns("A:A").Delete
      .ActiveWorkbook.SaveAs(m.f_othet,51)
      .Quit()
    Endwith
    If "[SHOW]"$Upper(m.rep_config)  && Показать отчет
      WSHShell=Createobject("WScript.Shell",0,.F.)
      WSHShell.Run('"'+m.f_othet+'"')
    Endif
  Endif
Endif
Erase (m.tmp_shabl)
Erase (m.tmp_othet)
Return m.rep_errs  && пустая, если все ОК!
*############################################################################################
*############################################################################################
*############################################################################################
Function DBF_TOEXCEL  && продвинутая выгрузка данных курсора в EXCEL
Parameters rep_alias,rep_xname,rep_config,rep_sourse,rep_filter,rep_cols
*--------------------------------------------------------------------------------------------
* @ TAS - 2019 г. Все параметры необязательны!
*--------------------------------------------------------------------------------------------
* 1. rep_alias    - Alias источника данных, если не задан, то берется текущий.
* 2. rep_xname    - наименование файла, если не задан, то результат будет открыт в EXCEL.
* 3. rep_config    - конфиг:
*    [SHOW]    - показать XLS отчет в EXCEL.
*    [EXCEL]    - вернуть объект для дополнительных действий.
*    [CTITL]    - выровнять заголовки колонок по центру и по середине высоты.
* 4. rep_sourse    - список полей для SELECT и сортировки в виде "fields1,fields2,fields3 ORDER= fields1,fields10"
*             можно указать * для включения в результат всех полей. Eсли не задан, то = "*".
*            Фрагмент "ORDER=" является необязательным и может включать поля, отсутствующие в SELECT.
* 5. rep_filter    - фильтр в виде условия для SQL запроса "field1=1 AND field2='ДА'" . Eсли не задан, то = "1=1".
* 6. rep_cols    - Доп настройки колонок через резделитель "|" в виде:.
*    "TC:1=текст1|TC:5=текст2"   - для изменения наименования указанных колонок
*    "WT:1=50|WT:5=20"       - для изменения ширины указанных колонок
*    "WR:1|WR:5"         - для включения WordWrap указанных колонок
*--------------------------------------------------------------------------------------------
* Примеры использования:
*--------------------------------------------------------------------------------------------
* ? DBF_TOEXCEL('xsddata','111.xls',"[SHOW][CTITL]")
* ? DBF_TOEXCEL('xsddata',"","[EXCEL][CTITL]")
*--------------------------------------------------------------------------------------------
* Возврат:
*  - пустая строка, если все ОК.
*  - текст ошибки при ошибки
*  - объект, если задан параметр [EXCEL] и не было ошибки. В объекте есть кол-во строк и колонок, а также сам oExcel.
*--------------------------------------------------------------------------------------------
Local oExcel, rep_xtemp, rep_select, rep_order, tmp_alias, rep_error, tek_alias, col_data, col_znah, tmp_field(1)
Local kol_rows, kol_cols, _my_rep, add_tmprow, col_maxlit
*--------------------------------------------------------------------------------------------
*  Проверки и первичная обработка входящих параметров
*--------------------------------------------------------------------------------------------
add_tmprow=0    && Если придутся добавлять строку, чтобы EXCEL добавил наименования колонок
rep_error=''    && Для ошибки
tek_alias=Alias()  && Сюда вернем алиас при выходе
rep_alias=Iif(Vartype(m.rep_alias)#"C" Or Empty(m.rep_alias),Alias(),m.rep_alias)
rep_xname=Iif(Vartype(m.rep_xname)#"C","",m.rep_xname)
rep_sourse=Iif(Vartype(m.rep_sourse)#"C" Or Empty(m.rep_sourse),"*",m.rep_sourse)
rep_filter=Iif(Vartype(m.rep_filter)#"C" Or Empty(m.rep_filter),"1=1",m.rep_filter)
rep_config=Iif(Vartype(m.rep_config)#"C","",m.rep_config)
rep_cols=Iif(Vartype(m.rep_cols)#"C","",m.rep_cols)
If Empty(m.rep_alias) Or !Used(m.rep_alias)
  If Vartype(m.proglang)="N" And m.proglang=1  && ENG
    Return 'No data source ALIAS specified or missing!'
  Else
    Return 'Не задан или отсутствует ALIAS источника данных!'
  Endif
Endif
If !Empty(m.rep_xname) And Empty(Justpath(m.rep_xname))
  m.rep_xname=Sys(5)+Curdir()+m.rep_xname  && дополняем полным путем
Endif
rep_xtemp=Sys(2023)+'\'+Sys(3)+'.xml'
If Empty(m.rep_filter)
  m.rep_filter="1=1"
Endif
If "ORDER="$Upper(m.rep_sourse)
  rep_order="ORDER BY "+Alltrim(Substr(m.rep_sourse,At("ORDER=",Upper(m.rep_sourse))+6))
  rep_sourse=Alltrim(Left(m.rep_sourse,At("ORDER=",Upper(m.rep_sourse))-1))
Else
  rep_order=''
Endif
*--------------------------------------------------------------------------------------------
*  Формирование курсора для отчета, при необходимости
*--------------------------------------------------------------------------------------------
Select (m.rep_alias)
Count To kol_rows
If m.rep_sourse=="*" And Empty(m.rep_order) And m.rep_filter=="1=1" And m.kol_rows>1
  tmp_alias=m.rep_alias
Else
  tmp_alias="_xlsreport"
  TEXT TO sqlzapr NOSHOW TEXTMERGE PRETEXT 15
      SELECT <<m.rep_sourse>>
      FROM <<m.rep_alias>>
      WHERE <<m.rep_filter>>
      INTO CURSOR <<m.tmp_alias>> READWRITE <<m.rep_order>>
  ENDTEXT
  Try
    Execscript(m.sqlzapr)
  Catch To goto_error
    If Vartype(m.proglang)="N" And m.proglang=1  && ENG
      rep_error="Error performing request "+goto_error.Message
    Else
      rep_error="Ошибка выполнения запроса "+goto_error.Message
    Endif
  Endtry
Endif
*--------------------------------------------------------------------------------------------
*  Формирование файла отчета
*--------------------------------------------------------------------------------------------
If Empty(m.rep_error)
  Try
    oExcel= Createobject("Excel.Application")
  Catch To goto_error

  Endtry
  If Vartype(m.oExcel)#"O"
    If Vartype(m.proglang)="N" And m.proglang=1  && ENG
      rep_error="Microsoft Excel is not installed!"
    Else
      rep_error="Не установлен Microsoft Excel!"
    Endif
  Endif
Endif
If Empty(m.rep_error)
  Select (m.tmp_alias)
  kol_cols=Afields(tmp_field,m.tmp_alias)
  Count To kol_rows
  Do Case
  Case m.kol_rows=0
    If Vartype(m.proglang)="N" And m.proglang=1  && ENG
      rep_error="There is no data to report!"
    Else
      rep_error="Нет данных для формирования отчета!"
    Endif
  Case m.kol_rows=1  && одна строка - нужно отработать особое поведение EXCEL - добавить и удалить доп строку, чтобы EXCEL добавил заголовки.
    Append Blank
    add_tmprow=1
  Endcase
Endif
With oExcel
  If Empty(m.rep_error)
    kol_rows=m.kol_rows+1              && прибавляем заголовок
    If Cursortoxml(m.tmp_alias, m.rep_xtemp,1,512+16,0)>0
      .DisplayAlerts = .F.
      .Workbooks.OpenXML(m.rep_xtemp,,2)
      Delete File (m.rep_xtemp)
*--------------------------------------------------------------------------------------------
*  Общее форматирование всего отчета
*--------------------------------------------------------------------------------------------
      With .Range(.Cells(1, 1), .Cells(m.kol_rows, m.kol_cols))
        .BorderS.Weight=2
        .BorderS.LineStyle=1
        .VerticalAlignment = 1
      Endwith
      If add_tmprow=1                && удаляем строку, которую добавили
        .Rows(m.kol_rows+1).Delete
      Endif
*--------------------------------------------------------------------------------------------
*  Формирование заголовков
*--------------------------------------------------------------------------------------------
      If "[CTITL]"$Upper(m.rep_config)      && Выровнять заголовки колонок по центру и по середине высоты
        With .Range(.Cells(1, 1), .Cells(m.kol_rows, m.kol_cols+1))
          .WrapText = .T.
          .HorizontalAlignment = 3
          .VerticalAlignment = 2
        Endwith
      Endif
*--------------------------------------------------------------------------------------------
*  Наименования, заданные пользователем
*--------------------------------------------------------------------------------------------
      If !Empty(m.rep_cols)            && заданы заголовки или другие настройки колонок
        For i=1 To Getwordcount(m.rep_cols,"|")
          col_data=Getwordnum(m.rep_cols,m.i,"|")
          kol_cols=m.i
          If Upper(Left(m.col_data,3))=="TC:" Or Upper(Left(m.col_data,3))=="WT:"  Or Upper(Left(m.col_data,3))=="WR:"  && указан номер колонки
            kol_cols=Getwordnum(m.col_data,1,"=")
            col_znah=Alltrim(Substr(m.col_data,At("=",m.col_data)+1))
            kol_cols=Val(Getwordnum(m.kol_cols,2,":"))
          Endif
          If !Empty(m.kol_cols)
            Do Case
            Case Upper(Left(m.col_data,3))=="TC:"
              .Cells(1,m.kol_cols).Value=m.col_znah
            Case Upper(Left(m.col_data,3))=="WT:"
              .Columns(m.kol_cols).ColumnWidth = Val(m.col_znah)
            Case Upper(Left(m.col_data,3))=="WR:"
              .Range(.Cells(2, kol_cols), .Cells(m.kol_rows, kol_cols)).WrapText = .T.
            Endcase
          Endif
        Endfor
      Endif
*--------------------------------------------------------------------------------------------
*  Операции с результатом
*--------------------------------------------------------------------------------------------
      Do Case
      Case "[EXCEL]"$Upper(m.rep_config)      && Вернуть объект для допиливания пользователем
        _my_rep=Createobject("EXCEL_REP")
        AddProperty(_my_rep, '_KolRow', m.kol_rows)
        AddProperty(_my_rep, '_KolCol', m.kol_cols)
        AddProperty(_my_rep, '_ColMax', m.col_maxlit)
        AddProperty(_my_rep, '_oExcel', m.oExcel)
        rep_error=m._my_rep
      Case Empty(m.rep_xname)            && не задан файл отчета
        .Visible= .T.            && просто показываем результат
      Otherwise
        Try
          .ActiveWorkbook.SaveAs(m.rep_xname,51)
        Catch To goto_error
          If Vartype(m.proglang)="N" And m.proglang=1  && ENG
            rep_error="Error saving report: "+goto_error.Message
          Else
            rep_error="Ошибка сохранения отчета: "+goto_error.Message
          Endif
        Endtry
        .Quit
        If Empty(m.rep_error) And "[SHOW]"$Upper(m.rep_config)  && Показать отчет перезагрузкой, чтобы обнулить историю изменения файла
          WSHShell=Createobject("WScript.Shell",0,.F.)
          WSHShell.Run('"'+m.rep_xname+'"')
        Endif
      Endcase
    Endif
  Endif
Endwith
Use In Select(m.tmp_alias)
If !Empty(m.tek_alias) And Used(m.tek_alias)
  Select (m.tek_alias)
Endif
Return m.rep_error
Define Class EXCEL_REP As Shape
Enddefine
